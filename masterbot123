
# ████████████████████████████████████████████████████████████████████████████
# █                                                                         █
# █                           MasterBot 12.92                               █
# █                                                                         █
# ████████████████████████████████████████████████████████████████████████████
# Описание: Telegram-бот для управления распределением ведущих на квесты.
# Основной функционал:
# - Загрузка сделок из AmoCRM с фильтрацией по статусам и датам.
# - Отображение новых и распределённых игр.
# - Создание Telegram-опросов для выбора ведущих.
# - Формирование отчётов по опросам и распределению.
# - Обновление AmoCRM и Google Sheets с результатами распределения.
# Версия: 12.92
# Дата: 13.05.2025

import asyncio
from contextlib import asynccontextmanager
import json
import logging
import os
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pytz
from aiogram import Bot, Dispatcher, Router, types
from aiogram.exceptions import TelegramAPIError, TelegramBadRequest
from aiogram.filters import Command, CommandStart
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton, ReplyKeyboardMarkup, KeyboardButton
from aiogram.utils.keyboard import InlineKeyboardBuilder
from aiogram.client.bot import DefaultBotProperties
from apscheduler.schedulers.asyncio import AsyncIOScheduler
import gspread
from google.oauth2.service_account import Credentials
import aiohttp
from logging.handlers import RotatingFileHandler


# ─────────────────────────────────────────────────────────────────────────────
# Форвард-декларация, чтобы Pylance видел get_distribution_keyboard
def get_distribution_keyboard() -> InlineKeyboardMarkup:
    """Заглушка для IDE; реальная функция определяется ниже."""
    pass
# ─────────────────────────────────────────────────────────────────────────────


# ╔═══════════════════════════════════════════════════════════════════════════╗
# ║                                                                           ║
# ║                       [1.0] Настройка логирования                         ║
# ║                                                                           ║
# ╚═══════════════════════════════════════════════════════════════════════════╝
# Описание: Инициализация системы логирования для вывода в консоль и файл с улучшенной детализацией.
# version: 1.2

LOG_DIR = os.path.join(os.path.dirname(os.path.abspath(__file__)), "logs")
os.makedirs(LOG_DIR, exist_ok=True)

logging.basicConfig(
    level=logging.DEBUG,
    format="%(asctime)s [%(levelname)s] [%(name)s] [%(filename)s:%(lineno)d] %(message)s",
    handlers=[
        RotatingFileHandler(
            os.path.join(LOG_DIR, "masterbot.log"),
            maxBytes=10 * 1024 * 1024,  # 10 MB
            backupCount=5,
            encoding="utf-8"
        ),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

# version: 1.2
# История изменений:
# - 1.0: Базовая настройка логирования.
# - 1.1 (11.05.2025): Добавлено указание раздела в сообщениях логов.
# - 1.2 (13.05.2025): Добавлена папка logs, улучшена структура хранения логов.

# ╔═══════════════════════════════════════════════════════════════════════════╗
# ║                                                                           ║
# ║                       [2.0] Конфигурация и константы                      ║
# ║                                                                           ║
# ╚═══════════════════════════════════════════════════════════════════════════╝
# Описание: Определяет параметры бота, пути к файлам, токены и настройки.
# version: 1.13

# Параметры бота
VERSION = "MasterBot 12.92"
CURRENT_YEAR = datetime.now().year
SPREADSHEET_NAME = f"Рабочие таблицы {CURRENT_YEAR}"
GOOGLE_API_RATE_LIMIT_SECONDS = 180
DATE_FILTER_THRESHOLD = timedelta(days=30)
POLL_DURATION = timedelta(hours=24)
CACHE_LIFETIME = timedelta(minutes=5)

# Токены и идентификаторы
API_TOKEN = "7637424219:AAHXYNXHrRNZ1XwNbLx7ieBTZtafe6pmkYo"
LEADER_ID = os.getenv("MASTERBOT_LEADER_ID", "1018880781")

if not API_TOKEN or not isinstance(API_TOKEN, str):
    logger.critical("[2.0] API_TOKEN не задан или не является строкой")
    raise SystemExit(1)
logger.info("[2.0] API_TOKEN успешно загружен")

try:
    LEADER_ID = int(LEADER_ID)
except (ValueError, TypeError):
    logger.error("[2.0] MASTERBOT_LEADER_ID должен быть числом, получено: %s", LEADER_ID)
    raise SystemExit(1)

# Пути к файлам
BASE_DIR = os.path.dirname(os.path.abspath(__file__))
LOG_FILE = os.path.join(BASE_DIR, "logs", "masterbot.log")
CHAT_ID_FILE = os.path.join(BASE_DIR, "chat_id.json")
MASTERBOT_DB = os.path.join(BASE_DIR, "masterbot.db")
CONFIG_FILE = os.path.join(BASE_DIR, "config.json")
TOKENS_FILE = os.path.join(BASE_DIR, "tokens.json")

# Учетные данные Google Sheets
GOOGLE_CREDENTIALS_FILE = os.getenv("GOOGLE_CREDENTIALS_PATH")
if not GOOGLE_CREDENTIALS_FILE:
    possible_files = [
        "svetofor-credentials.json",
        "service-account-key.json",
        "credentials.json"
    ]
    for fname in possible_files:
        candidate = os.path.join(BASE_DIR, fname)
        if os.path.exists(candidate):
            GOOGLE_CREDENTIALS_FILE = candidate
            logger.info("[2.0] Найден файл учетных данных Google Sheets: %s", GOOGLE_CREDENTIALS_FILE)
            break

if GOOGLE_CREDENTIALS_FILE and os.path.exists(GOOGLE_CREDENTIALS_FILE):
    try:
        with open(GOOGLE_CREDENTIALS_FILE, 'r', encoding='utf-8') as f:
            creds_data = json.load(f)
            client_email = creds_data.get("client_email", "не указан")
            logger.info("[2.0] Учетные данные Google Sheets загружены: client_email=%s", client_email)
    except (json.JSONDecodeError, KeyError) as e:
        logger.error("[2.0] Ошибка чтения файла учетных данных Google Sheets: %s", e, exc_info=True)
        GOOGLE_CREDENTIALS_FILE = None
else:
    GOOGLE_CREDENTIALS_FILE = os.path.join(BASE_DIR, "svetofor-credentials.json")
    logger.warning(
        "[2.0] Файл учетных данных Google Sheets не найден: %s. Функции Google Sheets будут недоступны.",
        GOOGLE_CREDENTIALS_FILE
    )

# Константы
SVETOFOR_SHEET = "Светофор"
DISTRIBUTION_SPREADSHEET_NAME = "Сводная таблица распределения"
ALLOWED_STATUSES = ["Бронь", "Закрытие сделки", "Предварительная заявка"]
ALLOWED_STATUS_IDS = ["18913933", "18960415", "18913930"]
NEW_GAMES_STATUS_IDS = ["18913930", "18913933"]
SUCCESSFUL_STATUS_ID = "18960415"
DATE_FILTER_DAYS = 30
PREPAYMENT_FIELD_ID = None
PACKAGE_FIELD_ID = "71673"
MSK_TZ = pytz.timezone("Europe/Moscow")
GOOGLE_SHEETS_SCOPES = [
    "https://www.googleapis.com/auth/spreadsheets",
    "https://www.googleapis.com/auth/drive"
]

# Права доступа
ACCESS = {
    "games": ["руководитель", "администратор", "ведущий", "ведущий новичок"],
    "poll": ["руководитель", "администратор"],
    "distribution": ["руководитель", "администратор"],
}

# Отображение дней недели
WEEKDAYS = {
    "Monday": "Пн", "Tuesday": "Вт", "Wednesday": "Ср", "Thursday": "Чт",
    "Friday": "Пт", "Saturday": "Сб", "Sunday": "Вск",
}

# Роли для игр
GAME_ROLE_MAPPING = {
    "Петля времени": {"main_leaders": 1, "assistants": 1},
    "Хранители волшебства": {"main_leaders": 1, "assistants": 1},
    "Время приключений": {"main_leaders": 1, "assistants": 2},
    "Кланы Нью-Йорка": {"main_leaders": 1, "assistants": 3},
    "Коллекционер игр": {"main_leaders": 1, "assistants": 1},
    "Бермудский треугольник": {"main_leaders": 1, "assistants": 3},
    "Старый дом": {"main_leaders": 1, "assistants": 1},
    "Цветочная башня": {"main_leaders": 2, "assistants": 0}
}


AMOCRM_FIELDS = {
    "event_date":     "87751",    # Дата
    "event_time":     "88565",    # время
    "game_name":      "87791",    # Квест
    "age":            "899511",   # Возраст игроков
    "extra_services": "452955",   # Дополнительно (Пиньята в подарок)
    "comment":        "87811",    # Комментарий
    "prepayment":     "100407",   # Предоплата
    "team_leads":     "88567",    # Ведущие
    "photographer":   "87813",    # Фотограф
    "players":        "71635",    # Количество игроков
    "package":        "71673",    # Пакет услуг
}

# version: 1.13
# История изменений:
# - 1.0: Исходная конфигурация.
# - 1.2: Улучшены проверки токена.
# - 1.3: Добавлена константа для сводной таблицы.
# - 1.4: Исправлен токен Telegram-бота, добавлена валидация токена.
# - 1.5: Перемещена настройка логирования для устранения NameError.
# - 1.6: Добавлена проверка существования файла учетных данных.
# - 1.7: Добавлена поддержка GOOGLE_CREDENTIALS_PATH.
# - 1.8: Добавлен поиск файлов учетных данных по типичным именам.
# - 1.9: Добавлено логирование client_email для диагностики.
# - 1.10: Изменён поиск файла учетных данных, добавлено имя svetofor-credentials.json.
# - 1.11: Исправлена ошибка с отступами в цикле for.
# - 1.12 (12.05.2025): API_TOKEN прописан в коде, добавлены MSK_TZ, GAME_ROLE_MAPPING, AMOCRM_FIELDS, улучшено логирование.
# - 1.13 (13.05.2025): Обновлены пути к файлам логов, добавлена папка logs.

# ╔═══════════════════════════════════════════════════════════════════════════╗
# ║                       [3.0] Глобальные объекты                            ║
# ║  version: 1.4 (08.06.2025) — добавлен detail_blocks                       ║
# ╚═══════════════════════════════════════════════════════════════════════════╝

from typing import Dict, List, Optional, Tuple
from datetime import datetime
from aiogram import types
from aiogram.types import InlineKeyboardMarkup


class BotData:
    """Все переменные, которые должны жить до перезапуска бота."""
    def __init__(self) -> None:
        # ── конфигурация / токены ───────────────────────────────────────────
        self.config: Dict = {}
        self.tokens: Dict = {}

        # ── Chat / Spreadsheet IDs ──────────────────────────────────────────
        self.admin_chat_id: Optional[int] = None
        self.svetofor_spreadsheet_id: Optional[str] = None

        # ── Опросы и распределение ─────────────────────────────────────────
        self.current_poll_deals: List[Dict] = []
        self.responses: Dict = {}                        # poll_id → ответы
        self.distribution_cache: Dict = {}               # deal_id → {role: tag}
        self.distribution_keyboard: Optional[InlineKeyboardMarkup] = None

        # ── Служебные указатели ─────────────────────────────────────────────
        self.personal_report_message_id: Optional[int] = None
        self.current_poll_leader: Optional[int] = None
        self.coordination_cycle_active: bool = False

        # ── Периоды отчётов ────────────────────────────────────────────────
        self.current_event_period: Optional[List[datetime]] = None
        self.last_event_period: Optional[List[datetime]] = None

        # ── Кеши сообщений ─────────────────────────────────────────────────
        self.pipeline_mapping: Dict = {}
        self.deals_cache: Dict = {}
        self.messages_to_delete: Dict[int, List[int]] = {}
        self.last_user_messages: Dict[int, List[types.Message]] = {}
        self.detail_blocks: Dict[Tuple[int, int], List[types.Message]] = {}  # (uid, deal) → msgs

        # ── UI-поддержка ───────────────────────────────────────────────────
        self.games_by_user: Dict[int, List[Dict]] = {}


bot_data = BotData()

# version-history:
# 1.0 — базовая структура
# 1.1 — deals_cache, messages_to_delete
# 1.2 — games_by_user
# 1.3 — last_user_messages
# 1.4 — detail_blocks



# ╔═══════════════════════════════════════════════════════════════════════════╗
# ║                                                                           ║
# ║                           [4.0] Утилиты                                   ║
# ║                                                                           ║
# ╚═══════════════════════════════════════════════════════════════════════════╝
# Описание: Вспомогательные функции для работы с данными.
# version: 1.1

def parse_players_count(players: Any) -> int:
    """Извлекает количество игроков из строки.

    Args:
        players: Значение поля players (строка, число или None).

    Returns:
        int: Количество игроков или 0 при ошибке.
    """
    try:
        if not players:
            return 0
        players_str = str(players).strip()
        if "-" in players_str:
            return int(players_str.split("-")[-1].strip())
        return int(players_str)
    except (ValueError, TypeError) as e:
        logger.warning("[4.0] parse_players_count: Некорректное значение players=%s: %s", players, e)
        return 0

async def load_json(file_path: str) -> Dict:
    """Загружает JSON-файл.

    Args:
        file_path: Путь к файлу.

    Returns:
        Dict: Данные из файла.

    Raises:
        FileNotFoundError: Если файл не найден.
        json.JSONDecodeError: Если файл содержит некорректный JSON.
    """
    if not os.path.exists(file_path):
        logger.error("[4.0] load_json: Файл %s не найден", file_path)
        raise FileNotFoundError(f"Файл {file_path} не найден")
    try:
        with open(file_path, "r", encoding="utf-8") as f:
            data = json.load(f)
            logger.debug("[4.0] load_json: Успешно загружен файл %s", file_path)
            return data
    except json.JSONDecodeError as e:
        logger.error("[4.0] load_json: Ошибка декодирования JSON в %s: %s", file_path, e)
        raise

async def save_json(file_path: str, data: Dict) -> bool:
    """Сохраняет данные в JSON-файл.

    Args:
        file_path: Путь к файлу.
        data: Данные для сохранения.

    Returns:
        bool: Успешность операции.
    """
    try:
        with open(file_path, "w", encoding="utf-8") as f:
            json.dump(data, f, indent=2, ensure_ascii=False)
        logger.debug("[4.0] save_json: Данные сохранены в %s", file_path)
        return True
    except Exception as e:
        logger.error("[4.0] save_json: Ошибка сохранения %s: %s", file_path, e, exc_info=True)
        return False

# version: 1.1
# История изменений:
# - 1.0: Базовые утилиты.
# - 1.1 (11.05.2025): Добавлено логирование с указанием раздела.

# ╔═══════════════════════════════════════════════════════════════════════════╗
# ║                   [5.0] Работа с Google Sheets                           ║
# ╚═══════════════════════════════════════════════════════════════════════════╝
# Описание: Читает лист «Светофор» из Google Sheets, кешируя метаданные и
#          данные, и возвращает для пользователя статус по цвету ячейки.
# version: 1.8 — единоразовая загрузка includeGridData, case-insensitive заголовки

from typing import Optional
import gspread
from google.oauth2.service_account import Credentials
from googleapiclient.discovery import build

# модуль-уровневый кеш
_svetofor_cache: dict = {
    "sheet": None,           # gspread.Worksheet
    "service": None,         # Google Sheets API client
    "spreadsheet_id": None,
    "rows": None,            # list[rowData]
    "headers": None,         # list[str] заголовки первой строки
}

def _init_svetofor() -> None:
    """Инициализирует sheet, service и spreadsheet_id один раз."""
    if _svetofor_cache["sheet"] is None:
        sid = bot_data.config.get("svetofor_spread_id")
        if not sid:
            raise RuntimeError("[5.0] _init_svetofor: 'svetofor_spread_id' не задан")
        creds = Credentials.from_service_account_file(
            GOOGLE_CREDENTIALS_FILE, scopes=GOOGLE_SHEETS_SCOPES
        )
        client = gspread.authorize(creds)
        sheet = client.open_by_key(sid).sheet1
        service = build("sheets", "v4", credentials=creds)

        _svetofor_cache.update({
            "sheet": sheet,
            "service": service,
            "spreadsheet_id": sid,
        })

def _load_svetofor_data() -> None:
    """
    Загружает meta с includeGridData и сохраняет строки + заголовки.
    Вызывается единожды за генерацию отчёта.
    """
    if _svetofor_cache["rows"] is None:
        svc = _svetofor_cache["service"]
        sid = _svetofor_cache["spreadsheet_id"]
        meta = svc.spreadsheets().get(
            spreadsheetId=sid, includeGridData=True
        ).execute()

        # найдём нужный лист по sheetId
        props = _svetofor_cache["sheet"].id
        sheet_meta = next(
            s for s in meta["sheets"]
            if s["properties"]["sheetId"] == props
        )
        rows = sheet_meta["data"][0].get("rowData", [])
        # первая строка — заголовки
        header_cells = rows[0].get("values", [])
        headers = [
            c.get("formattedValue", "").strip()
            for c in header_cells
        ]

        _svetofor_cache["rows"] = rows
        _svetofor_cache["headers"] = headers

async def get_user_row_from_svetofor(user_id: int) -> Optional[int]:
    """
    Ищет user_id (в коло́нке B) и возвращает номер строки (1-based),
    или None, если не найден.
    """
    try:
        _init_svetofor()
        _load_svetofor_data()
        rows = _svetofor_cache["rows"]
        target = str(user_id)
        for idx, row in enumerate(rows, start=1):
            vals = row.get("values", [])
            # столбец B → индекс 1
            if len(vals) > 1 and vals[1].get("formattedValue", "").strip() == target:
                return idx
    except Exception as e:
        logger.error("[5.0] get_user_row_from_svetofor: %s", e, exc_info=True)
    return None

async def get_game_column_from_svetofor(game_name: str) -> Optional[int]:
    """
    Ищет заголовок game_name в первой строке (без учёта регистра),
    возвращает номер столбца (1-based) или None.
    """
    try:
        _init_svetofor()
        _load_svetofor_data()
        norm = game_name.strip().lower()
        for idx, title in enumerate(_svetofor_cache["headers"], start=1):
            if title.lower() == norm:
                return idx
        logger.warning("[5.0] get_game_column: заголовок %r не найден", game_name)
    except Exception as e:
        logger.error("[5.0] get_game_column_from_svetofor: %s", e, exc_info=True)
    return None

def _rgb_to_status(r: float, g: float, b: float) -> str:
    """
    Преобразует backgroundColor из 0.0–1.0 в:
      green  if (g>0.5 and r<0.5)
      yellow if (r>0.5 and g>0.5)
      red    if (r>0.5 and g<0.5)
      ""     иначе
    """
    if g > 0.5 and r < 0.5:
        return "green"
    if r > 0.5 and g > 0.5:
        return "yellow"
    if r > 0.5 and g < 0.5:
        return "red"
    return ""

async def get_user_status_from_svetofor(user_id: int, game_name: str) -> str:
    """
    По user_id и game_name возвращает цвет ячейки:
    'green' | 'yellow' | 'red' | ''.
    """
    try:
        row = await get_user_row_from_svetofor(user_id)
        col = await get_game_column_from_svetofor(game_name)
        if not row or not col:
            return ""
        # берём из кешированных rows
        cell = _svetofor_cache["rows"][row - 1] \
                    .get("values", [])[col - 1]
        bg = cell.get("effectiveFormat", {}) \
                 .get("backgroundColor", {})
        return _rgb_to_status(
            bg.get("red",   0.0),
            bg.get("green", 0.0),
            bg.get("blue",  0.0)
        )
    except Exception as e:
        logger.error("[5.0] get_user_status_from_svetofor: %s", e, exc_info=True)
        return ""


# ╔═══════════════════════════════════════════════════════════════════════════╗
# ║                                                                           ║
# ║                       [6.0] Работа с AmoCRM                               ║
# ║                                                                           ║
# ╚═══════════════════════════════════════════════════════════════════════════╝
# Описание: Функции для получения и обновления данных в AmoCRM с расширенным логированием.
# version: 2.3

# ───────────────────────────────── ensure_valid_token ─────────────────────────
async def ensure_valid_token() -> bool:
    """Возвращает True, если access‑token действителен (или успешно обновлён)."""
    try:
        if not bot_data.tokens:
            bot_data.tokens = await load_json(TOKENS_FILE)
            if not bot_data.tokens:
                logger.error("[6.0] ensure_valid_token: файл токенов пуст %s", TOKENS_FILE)
                return False

        expires_at = bot_data.tokens.get("expires_at", 0)
        if datetime.now().timestamp() >= expires_at - 300:
            logger.info("[6.0] ensure_valid_token: token истекает, обновляем …")
            return await refresh_amocrm_token()

        logger.debug("[6.0] ensure_valid_token: token ok до %s",
                     datetime.fromtimestamp(expires_at))
        return True
    except Exception as e:
        logger.exception("[6.0] ensure_valid_token: критическая ошибка %s", e)
        return False


# ─────────────────────────────── refresh_amocrm_token ────────────────────────
async def refresh_amocrm_token() -> bool:
    """Обновляет refresh‑токен и сохраняет на диск."""
    try:
        cfg = bot_data.config or {}
        required = ("client_id", "client_secret", "redirect_uri", "domain")
        if any(k not in cfg for k in required):
            logger.error("[6.0] refresh_amocrm_token: неполный конфиг AmoCRM %s", cfg)
            return False

        async with aiohttp.ClientSession() as s:
            payload = {
                "client_id":     cfg["client_id"],
                "client_secret": cfg["client_secret"],
                "grant_type":    "refresh_token",
                "refresh_token": bot_data.tokens.get("refresh_token", ""),
                "redirect_uri":  cfg["redirect_uri"],
            }
            async with s.post(f"https://{cfg['domain']}/oauth2/access_token",
                              json=payload) as r:
                if r.status != 200:
                    logger.error("[6.0] refresh_amocrm_token: HTTP %d – %s",
                                 r.status, await r.text())
                    return False
                data = await r.json()
                data["expires_at"] = (
                    datetime.now() + timedelta(seconds=data.get("expires_in", 86400))
                ).timestamp()
                bot_data.tokens.update(data)
                await save_json(TOKENS_FILE, bot_data.tokens)
                logger.info("[6.0] refresh_amocrm_token: token обновлён")
                return True
    except Exception as e:
        logger.exception("[6.0] refresh_amocrm_token: сбой %s", e)
        return False


# ──────────────────────────────── get_pipeline_stages ────────────────────────
async def get_pipeline_stages() -> Dict[str, str]:
    """ID‑→‑Название статусов всех воронок."""
    try:
        if not await ensure_valid_token():
            return {}

        async with aiohttp.ClientSession() as s:
            head = {"Authorization": f"{bot_data.tokens['token_type']} {bot_data.tokens['access_token']}"}
            async with s.get(f"https://{bot_data.config['domain']}/api/v4/leads/pipelines",
                             headers=head) as r:
                if r.status != 200:
                    logger.error("[6.0] get_pipeline_stages: HTTP %d", r.status)
                    return {}
                js = await r.json()
                stages = {
                    str(st["id"]): st["name"]
                    for pl in js["_embedded"]["pipelines"]
                    for st in pl["_embedded"]["statuses"]
                }
                logger.debug("[6.0] get_pipeline_stages: %d статусов", len(stages))
                return stages
    except Exception as e:
        logger.exception("[6.0] get_pipeline_stages: ошибка %s", e)
        return {}


# ───────────────────────────────── get_custom_fields ─────────────────────────
async def get_custom_fields() -> Dict[str, str]:
    """ID‑→‑Название всех кастомных полей сделок."""
    try:
        if not await ensure_valid_token():
            return {}

        async with aiohttp.ClientSession() as s:
            head = {"Authorization": f"{bot_data.tokens['token_type']} {bot_data.tokens['access_token']}"}
            async with s.get(f"https://{bot_data.config['domain']}/api/v4/leads/custom_fields",
                             headers=head) as r:
                if r.status != 200:
                    logger.error("[6.0] get_custom_fields: HTTP %d", r.status)
                    return {}
                js = await r.json()
                fields = {str(f["id"]): f["name"] for f in js["_embedded"]["custom_fields"]}
                logger.debug("[6.0] get_custom_fields: %d полей", len(fields))
                return fields
    except Exception as e:
        logger.exception("[6.0] get_custom_fields: ошибка %s", e)
        return {}


# ─────────────────────────────── fetch_amocrm_deals ─────────────────────────
async def fetch_amocrm_deals(spreadsheet_id: str) -> List[Dict]:
    """Ходит в AmoCRM, возвращает обработанные сделки."""
    try:
        if not bot_data.config or not await ensure_valid_token():
            return []

        custom_fields, stages = await asyncio.gather(
            get_custom_fields(), get_pipeline_stages()
        )
        if not custom_fields or not stages:
            return []

        # 👉 сохраняем ID поля «Предоплата»
        global PREPAYMENT_FIELD_ID
        PREPAYMENT_FIELD_ID = next(
            (fid for fid, name in custom_fields.items() if "предоплат" in name.lower()),
            None
        )

        deals: List[Dict] = []
        page, limit = 1, 250
        updated_from = int((datetime.now() - timedelta(days=DATE_FILTER_DAYS)).timestamp())
        pipeline_id = bot_data.config.get("pipeline_id")  # может быть None

        async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=20)) as s:
            head = {"Authorization": f"{bot_data.tokens['token_type']} {bot_data.tokens['access_token']}"}

            while True:
                params: Dict[str, Union[str, int]] = {
                    "with": "contacts,tags",
                    "limit": limit,
                    "page": page,
                    "filter[updated_at][from]": updated_from,
                }
                # не отправляем None → иначе TypeError inside yarl
                if pipeline_id:
                    params["filter[pipeline_id]"] = pipeline_id

                # корректное перечисление статусов (как в рабочей 12.90)
                for i, sid in enumerate(ALLOWED_STATUS_IDS):
                    params[f"filter[statuses][{i}][pipeline_id][0][statuses][0]"] = sid

                async with s.get(f"https://{bot_data.config['domain']}/api/v4/leads",
                                 headers=head, params=params) as r:
                    logger.debug("[6.0] fetch_amocrm_deals: p.%d http=%d", page, r.status)

                    if r.status == 204:
                        break
                    if r.status == 401 and await refresh_amocrm_token():
                        head["Authorization"] = (
                            f"{bot_data.tokens['token_type']} {bot_data.tokens['access_token']}"
                        )
                        continue
                    if r.status != 200:
                        logger.error("[6.0] fetch_amocrm_deals: HTTP %d – %s",
                                     r.status, await r.text())
                        return []

                    js = await r.json()
                    leads = js.get("_embedded", {}).get("leads", [])
                    if not leads:
                        break

                    for raw in leads:
                        if str(raw.get("status_id")) in ALLOWED_STATUS_IDS:
                            processed = await process_deal(raw, stages, custom_fields, spreadsheet_id)
                            if processed:
                                deals.append(processed)

                    page += 1
                    await asyncio.sleep(1)  # soft‑limit

        deals.sort(key=lambda d: d["event_datetime"])
        logger.info("[6.0] fetch_amocrm_deals: %d сделок", len(deals))
        return deals

    except Exception as e:
        logger.exception("[6.0] fetch_amocrm_deals: критическая ошибка %s", e)
        return []


# ───────────────────────────────── get_amocrm_deals ─────────────────────────
async def get_amocrm_deals(spreadsheet_id: str, refresh: bool = False) -> List[Dict]:
    """Возвращает сделки из кэша либо обновляет кэш при необходимости."""
    try:
        cache_key = f"deals_{spreadsheet_id}"
        cache_entry = bot_data.deals_cache.get(cache_key)
        if cache_entry and not refresh:
            age = datetime.now() - cache_entry["timestamp"]
            if age < CACHE_LIFETIME:
                logger.debug("[6.0] deals‑cache HIT | %s | age %.1fs", spreadsheet_id, age.total_seconds())
                return cache_entry["deals"]

        deals = await fetch_amocrm_deals(spreadsheet_id)
        bot_data.deals_cache[cache_key] = {"deals": deals, "timestamp": datetime.now()}
        logger.debug("[6.0] deals‑cache обновлён | %s | %d сделок", spreadsheet_id, len(deals))
        return deals
    except Exception as e:
        logger.exception("[6.0] get_amocrm_deals: ошибка %s", e)
        return []


# ─────────────────────────────── update_amocrm_tags ─────────────────────────
async def update_amocrm_tags(deal_id: int, tags: List[str]) -> bool:
    """Патчит теги сделки.  True → успешно."""
    try:
        if not await ensure_valid_token():
            return False

        async with aiohttp.ClientSession() as s:
            head = {"Authorization": f"{bot_data.tokens['token_type']} {bot_data.tokens['access_token']}"}
            payload = {"_embedded": {"tags": [{"name": t} for t in tags]}}

            async with s.patch(f"https://{bot_data.config['domain']}/api/v4/leads/{deal_id}",
                               headers=head, json=payload) as r:
                if r.status == 429:
                    await asyncio.sleep(1)
                    async with s.patch(f"https://{bot_data.config['domain']}/api/v4/leads/{deal_id}",
                                       headers=head, json=payload) as r2:
                        r = r2  # повторный ответ

                if r.status != 200:
                    logger.error("[6.0] update_amocrm_tags: HTTP %d – %s", r.status, await r.text())
                    return False

                logger.info("[6.0] update_amocrm_tags: ok deal=%d %s", deal_id, tags)
                return True
    except Exception as e:
        logger.exception("[6.0] update_amocrm_tags: ошибка %s", e)
        return False

# version: 2.3
# История изменений:
# - 2.0 (12.05.2025): пагинация, расширенный лог.
# - 2.1 (13.05.2025): детализация ошибок.
# - 2.2 (14.05.2025): фиксы JSON‑decode и rate‑limit.
# - 2.3 (15.05.2025): исключён pipeline_id=None, статусы формируются корректно —
#                    устранён TypeError «Invalid variable type» при запросе.

# ╔═══════════════════════════════════════════════════════════════════════════╗
# ║                                                                           ║
# ║                   [7.0] Обработка данных AmoCRM                           ║
# ║                                                                           ║
# ╚═══════════════════════════════════════════════════════════════════════════╝
# Описание: превращает «сырую» сделку из AmoCRM в единый dict для бота.
#           • Поддерживает множественные значения для поля «Доп. услуги»
#           • Понимает Unix-таймстамп (сек/мс) и текстовые форматы даты/времени
#           • Всегда возвращает отдельное поле event_time (строка «HH:MM»)
#           • Логирует только начало и результат обработки
# version: 2.8 (13.05.2025) — сокращено логирование, добавлено отображение комментариев

def _parse_event_datetime(raw_date: Any, raw_time: Any) -> Optional[datetime]:
    """
    Универсальный парсер даты + времени из AmoCRM.
    """
    try:
        ts = float(raw_date)
        if ts > 1e12:
            ts /= 1000
        return MSK_TZ.localize(datetime.fromtimestamp(int(ts)))
    except (TypeError, ValueError):
        pass

    date_str = str(raw_date or "").strip()
    time_str = str(raw_time or "").strip()
    if time_str.lower() == "не указано":
        time_str = ""
    candidate = f"{date_str} {time_str}".strip()

    for fmt in (
        "%Y-%m-%d %H:%M", "%d.%m.%Y %H:%M",
        "%d/%m/%Y %H:%M", "%Y.%m.%d %H:%M",
        "%Y-%m-%d",      "%d.%m.%Y",
        "%d/%m/%Y",      "%Y.%m.%d"
    ):
        try:
            dt = datetime.strptime(candidate, fmt)
            if " %H:%M" not in fmt:
                dt = dt.replace(hour=0, minute=0)
            return MSK_TZ.localize(dt)
        except ValueError:
            continue

    return None


async def process_deal(
    deal: Dict,
    stages: Dict[str, str],
    custom_fields: Dict[str, str],
    spreadsheet_id: str,
) -> Optional[Dict]:
    """
    Преобразует «сырую» сделку AmoCRM в унифицированный dict.
    """
    deal_id = deal.get("id")
    if not deal_id:
        logger.warning("[7.0] process_deal: нет id сделки")
        return None

    logger.info("[7.0] process_deal START deal_id=%s", deal_id)

    try:
        # Собираем custom_fields_values
        cf_raw = deal.get("custom_fields_values") or []
        cf: Dict[str, List[Any]] = {
            str(f.get("field_id")): [v["value"] for v in f.get("values", []) if v.get("value") is not None]
            for f in cf_raw
        }

        # Парсим дату и время
        raw_date = cf.get(AMOCRM_FIELDS["event_date"], [None])[0]
        raw_time = cf.get(AMOCRM_FIELDS["event_time"], [""])[0]
        event_dt = _parse_event_datetime(raw_date, raw_time)
        if not event_dt:
            logger.error("[7.0] process_deal: не удалось распарсить дату deal_id=%s", deal_id)
            return None
        event_time = (str(raw_time).strip()
                      if raw_time and str(raw_time).strip().lower() != "не указано"
                      else event_dt.strftime("%H:%M"))

        # Финансы
        def to_int(val, default=0):
            try:
                return int(float(str(val).replace(",", ".")))
            except (TypeError, ValueError):
                return default

        total_budget = deal.get("price", 0)
        prepayment   = to_int(cf.get(AMOCRM_FIELDS["prepayment"], [0])[0])
        to_calculate = total_budget - prepayment

        # Ведущие
        leads_raw = cf.get(AMOCRM_FIELDS["team_leads"], [])
        team_leads = [
            {"id": lid, "name": get_lead_name(lid)}
            for lid in map(str, leads_raw) if lid.strip()
        ]

        # Доп. услуги
        pinata_list    = cf.get(AMOCRM_FIELDS["extra_services"], [])  # «Пиньята в подарок»
        other_services = cf.get("413875", [])  # «Дополнительно»
        all_services   = pinata_list + other_services
        extra_services = ", ".join(map(str, all_services)) if all_services else ""

        # Пакет услуг
        package_list = cf.get(AMOCRM_FIELDS["package"], [""])
        package = str(package_list[0]) if package_list else ""

        # Прочие поля
        game_name    = cf.get(AMOCRM_FIELDS["game_name"], [""])[0]
        players      = cf.get(AMOCRM_FIELDS["players"], [""])[0]
        age          = cf.get(AMOCRM_FIELDS["age"], [""])[0]
        comment      = cf.get(AMOCRM_FIELDS["comment"], [""])[0] or ""
        photographer = cf.get(AMOCRM_FIELDS["photographer"], [""])[0] or ""

        processed = {
            "id":                 deal_id,
            "name":               deal.get("name", f"Сделка {deal_id}"),
            "game_name":          game_name,
            "status_id":          str(deal.get("status_id", "")),
            "status":             stages.get(str(deal.get("status_id", "")), "Неизвестно"),
            "event_datetime":     event_dt,
            "event_datetime_str": f"{event_dt.strftime('%d.%m.%Y')}, {event_time}",
            "event_time":         event_time,
            "players":            players,
            "players_count":      parse_players_count(players),
            "age":                age,
            "package":            package,
            "extra_services":     extra_services,
            "comment":            comment,
            "total_budget":       total_budget,
            "prepayment":         prepayment,
            "to_calculate":       to_calculate,
            "team_leads":         team_leads,
            "photographer":       photographer,
        }

        logger.info("[7.0] process_deal DONE deal_id=%s", deal_id)
        return processed

    except Exception as e:
        logger.exception("[7.0] process_deal: ошибка deal_id=%s: %s", deal_id, e)
        return None


# ╔═══════════════════════════════════════════════════════════════════════════╗
# ║                                                                           ║
# ║                    [8.0] Пользовательские данные                          ║
# ║                                                                           ║
# ╚═══════════════════════════════════════════════════════════════════════════╝
# Описание: Функции для работы с информацией о пользователях из SQLite (checklists.db).
# version: 1.3

def get_user_info(user_id: int) -> Optional[Dict]:
    """Получает информацию о пользователе из SQLite.

    Args:
        user_id: ID пользователя.

    Returns:
        Optional[Dict]: {
            first_name: str,
            last_name_initial: str,
            role: str,
            status: str,
            games_last_30_days: int
        } или None, если не найден.
    """
    try:
        import sqlite3

        db_path = os.path.join(BASE_DIR, "checklists.db")
        conn = sqlite3.connect(db_path)
        cursor = conn.cursor()
        cursor.execute(
            "SELECT first_name, last_name, role FROM users WHERE user_id = ?",
            (user_id,)
        )
        row = cursor.fetchone()
        conn.close()

        if not row:
            logger.warning("[8.0] get_user_info: Пользователь %d не найден в базе %s", user_id, db_path)
            return None

        first_name, last_name, role = row
        last_initial = last_name[0] if last_name else ""
        user_data = {
            "first_name": first_name or "",
            "last_name_initial": last_initial,
            "role": role or "",
            "status": "green",
            "games_last_30_days": 0
        }
        logger.debug("[8.0] get_user_info: Загружен '%s' для пользователя %d", role, user_id)
        return user_data

    except Exception as e:
        logger.error("[8.0] get_user_info: Ошибка чтения из базы для %d: %s", user_id, e, exc_info=True)
        return None

def get_lead_name(lead_id: str) -> str:
    """Получает имя ведущего по ID.

    Args:
        lead_id: ID ведущего.

    Returns:
        str: Имя ведущего.
    """
    try:
        logger.debug("[8.0] get_lead_name: Запрошено имя для lead_id %s", lead_id)
        return "Unknown Lead"
    except Exception as e:
        logger.error("[8.0] get_lead_name: Ошибка для lead_id %s: %s", lead_id, e, exc_info=True)
        return "Unknown Lead"

# version: 1.3
# История изменений:
# - 1.0: Базовые заглушки.
# - 1.1 (11.05.2025): Добавлено логирование с разделом.
# - 1.2 (12.05.2025): Реально возвращали роль «руководитель» для LEADER_ID.
# - 1.3 (12.05.2025): Подключение к базе checklists.db для получения first_name, last_name и role.

# ╔═══════════════════════════════════════════════════════════════════════════╗
# ║                                                                           ║
# ║                        [9.0] Маппинг данных                               ║
# ║                                                                           ║
# ╚═══════════════════════════════════════════════════════════════════════════╝
# Описание: Генерация маппинга для pipeline и статусов.
# version: 1.1

async def generate_name_mapping() -> None:
    """Генерирует маппинг pipeline и статусов."""
    try:
        bot_data.pipeline_mapping = {
            "pipeline_id": {
                "name": "Main Pipeline",
                "stages": {
                    "142": "New",
                    "18913933": "In Progress",
                    "18913930": "Successful"
                }
            }
        }
        logger.info("[9.0] generate_name_mapping: Маппинг pipeline сгенерирован")
    except Exception as e:
        logger.error("[9.0] generate_name_mapping: Ошибка генерации маппинга: %s", e, exc_info=True)
        
# ╔═══════════════════════════════════════════════════════════════════════════╗
# ║                  [10.0] Telegram-обработчики  (v3.3 – 12-06-2025)         ║
# ║  /start · «📅 Новые игры» · «✅ Распределённые игры» · «📋 Создать опрос»    ║
# ║                                                                           ║
# ║  Ключевые изменения:                                                      ║
# ║  • _refresh_menu гарантирует ровно ОДНУ «Панель управления»:              ║
# ║      – сначала пытается править существующее меню через edit_message_text ║
# ║      – при неудаче удаляет старое и создаёт новое                         ║
# ║      – старый message_id кладёт в messages_to_delete → vacuum уберёт      ║
# ║  • vacuum по-прежнему игнорирует menu_message_id                         ║
# ║  • остальная логика (triggers, доступы) без изменений                    ║
# ╚═══════════════════════════════════════════════════════════════════════════╝
from aiogram.types import ReplyKeyboardRemove
from datetime import datetime, timedelta

router = Router()

# ───────────────────── helper: мгновенно удаляем команду ────────────────────
async def _delete_trigger(msg: types.Message) -> None:
    try:
        await msg.delete()
    except Exception:
        bot_data.messages_to_delete.setdefault(msg.from_user.id, []).append(msg.message_id)

# ───────────────────── helper: «тихое» меню — только кнопки ─────────────────
# v1.5 — без текста. Только reply_markup.
async def _refresh_menu(user_id: int) -> None:
    kb = await get_main_menu(user_id)
    if not kb:
        return

    old_id = getattr(bot_data, "menu_message_id", None)

    # ▶ пробуем обновить существующее меню
    if old_id:
        try:
            await bot.edit_message_text(
                text="‎",  # U+200E — невидимый символ
                chat_id=user_id,
                message_id=old_id,
                reply_markup=kb
            )
            return
        except TelegramBadRequest as e:
            if "message is not modified" in str(e):
                return
        except Exception:
            pass

        try:
            await bot.delete_message(chat_id=user_id, message_id=old_id)
        except Exception:
            pass
        bot_data.messages_to_delete.setdefault(user_id, []).append(old_id)
        bot_data.menu_message_id = None

    # ▶ создаём новое меню без текста
    try:
        sent = await bot.send_message(
            chat_id=user_id,
            text="‎",  # invisible text again
            reply_markup=kb
        )
        bot_data.menu_message_id = sent.message_id
        logger.debug("[10.0] _refresh_menu: новое пустое меню id=%d", sent.message_id)
    except Exception as e:
        logger.error("[10.0] _refresh_menu: создание не удалось: %s", e, exc_info=True)


# ─────────────────────────────── /start ─────────────────────────────────────
@router.message(CommandStart())
async def start_handler(message: types.Message) -> None:
    uid = message.from_user.id
    try:
        # vacuum удалит всё, кроме (будущего) меню
        await delete_previous_private_messages(uid)

        kb  = await get_main_menu(uid)
        txt = (
            f"🎉 Привет, {message.from_user.first_name or 'Пользователь'}!\n"
            f"Я *MasterBot* {VERSION} 🤖\n"
            f"Твой ID: `{uid}`\n"
        )
        if not kb:
            txt += "К сожалению, у тебя нет доступных действий."
        else:
            txt += "Я помогу управлять распределением ведущих на квесты."

        # show greeting (не путать с меню)
        await message.answer(txt, reply_markup=kb or ReplyKeyboardRemove())
        await _delete_trigger(message)                # скрываем /start

        # меню создаётся/обновляется отдельно
        await _refresh_menu(uid)
    except Exception as e:
        logger.error("[10.0] start_handler: %s", e, exc_info=True)

# ───────────────────────────── быстрые меню-команды ─────────────────────────
@router.message(lambda m: m.text and m.text.strip() in {"📅 Новые игры", "\U0001F4C5 Новые игры"})
async def new_games_handler(message: types.Message) -> None:
    uid = message.from_user.id
    if (info := get_user_info(uid)) and info["role"] in ACCESS["games"]:
        await delete_previous_private_messages(uid)
        await show_games(message, uid, NEW_GAMES_STATUS_IDS, "📅 Новые игры:", True)
    else:
        await message.answer("⛔ Нет доступа.", reply_markup=await get_main_menu(uid))
    await _delete_trigger(message)

@router.message(lambda m: m.text and m.text.strip() == "✅ Распределённые игры")
async def assigned_games_handler(message: types.Message) -> None:
    uid = message.from_user.id
    if (info := get_user_info(uid)) and info["role"] in ACCESS["games"]:
        await delete_previous_private_messages(uid)
        await show_games(message, uid, [SUCCESSFUL_STATUS_ID], "✅ Распределённые игры:")
    else:
        await message.answer("⛔ Нет доступа.", reply_markup=await get_main_menu(uid))
    await _delete_trigger(message)

# ──────────────── 📋 Создать опрос (фикс «меню пропадало») ──────────────────
@router.message(lambda m: m.text and m.text.strip() == "📋 Создать опрос")
async def create_poll_handler(message: types.Message) -> None:
    uid = message.from_user.id

    # — проверки доступа —
    if not await has_access(uid, "poll"):
        await message.answer("⛔ Нет доступа.", reply_markup=await get_main_menu(uid))
        await _delete_trigger(message); return
    if bot_data.coordination_cycle_active:
        await message.answer("⚠️ Уже есть активный опрос.")
        await _delete_trigger(message); return
    if not bot_data.admin_chat_id or not await is_bot_admin(bot_data.admin_chat_id):
        await message.answer("⚠️ Чат ведущих не настроен или бот не админ.")
        await _delete_trigger(message); return
    if not (sid := bot_data.config.get("svetofor_spread_id")):
        await message.answer("⚠️ Не указан ID таблицы «Светофор».")
        await _delete_trigger(message); return

    await delete_previous_private_messages(uid)

    # — собираем сделки —
    deals = await get_amocrm_deals(sid)
    now, window_end = datetime.now(tz=MSK_TZ), datetime.now(tz=MSK_TZ) + timedelta(days=14)
    poll_deals = [
        d for d in deals
        if d["status_id"] in NEW_GAMES_STATUS_IDS
           and now <= d["event_datetime"] <= window_end
           and not d["team_leads"]
    ]
    if not poll_deals:
        await message.answer("😔 Нет подходящих игр для опроса.",
                             reply_markup=await get_main_menu(uid))
        await _delete_trigger(message); return

    # — фиксируем контекст опроса —
    bot_data.current_poll_deals        = poll_deals
    bot_data.current_poll_leader       = uid
    bot_data.responses.clear()
    bot_data.distribution_cache.clear()
    bot_data.coordination_cycle_active = True     # ← кнопка «📊» в меню

    # — публикуем poll-сообщения —
    urgent      = any(d["event_datetime"] <= now + timedelta(days=3) for d in poll_deals)
    base_header = "🚨 Срочные игры!" if urgent else "📊 Новые игры"
    chunks      = [poll_deals[i:i + 8] for i in range(0, len(poll_deals), 8)]

    for idx, chunk in enumerate(chunks, 1):
        header  = f"{base_header} (Часть {idx})" if len(chunks) > 1 else base_header
        options, indices = [], {}
        for i, d in enumerate(chunk):
            date  = d["event_datetime"].strftime("%d.%m")
            title = f"🎉 {d['name']} – {date}"
            if d["package"]:         title += f" – {d['package']}"
            if d["extra_services"]:
                rest  = 100 - len(title) - 1
                extra = d["extra_services"]
                if len(extra) > rest:
                    extra = extra[:rest - 1].rstrip(', ') + "…"
                title += f" {extra}"
            options.append(title[:100]); indices[i] = d["id"]

        options += ["🚫 Не смогу работать", "🛡️ Могу администратором"]

        poll_msg = await bot.send_poll(
            bot_data.admin_chat_id, header, options,
            is_anonymous=False, allows_multiple_answers=True
        )
        bot_data.responses[poll_msg.poll.id] = {
            "deals":           {d["id"]: [] for d in chunk},
            "admin_available": [],
            "not_available":   [],
            "deal_indices":    indices
        }

    # — подтверждение и чистка триггера —
    ok = await message.answer("✅ Опросы отправлены.")          # без клавиатуры!
    bot_data.messages_to_delete.setdefault(uid, []).extend([message.message_id, ok.message_id])

    # — обновляем уже существующее меню —
    await _refresh_menu(uid)

    # — личный дашборд —
    dash = await bot.send_message(
        uid,
        await generate_poll_report(),
        reply_markup=bot_data.distribution_keyboard,
        parse_mode="Markdown"
    )
    bot_data.last_user_messages[uid]   = [dash]
    bot_data.personal_report_message_id = dash.message_id

    await report_unknown_names()

    scheduler.add_job(
        clear_poll_data,
        "date",
        run_date=now + POLL_DURATION,
        args=[uid],
        id=f"clear_poll_{uid}",
        replace_existing=True
    )

# ╔═══════════════════════════════════════════════════════════════════════════╗
# ║               [10.1] poll_report_handler  (v1.3)                         ║
# ║  «📊 Отчёт по опросу» – логика без изменений, но меню остаётся.            ║
# ╚═══════════════════════════════════════════════════════════════════════════╝
@router.message(lambda m: m.text and m.text.strip() in {"📊 Отчёт по опросу", "\U0001F4CA Отчёт по опросу"})
async def poll_report_handler(message: types.Message) -> None:
    uid = message.from_user.id
    if not await has_access(uid, "poll"):
        await message.answer("⛔ Нет доступа.", reply_markup=await get_main_menu(uid))
        await _delete_trigger(message); return
    if not bot_data.coordination_cycle_active:
        await message.answer("⚠️ Активных опросов нет.", reply_markup=await get_main_menu(uid))
        await _delete_trigger(message); return

    await delete_previous_private_messages(uid)

    dash = await bot.send_message(
        uid,
        await generate_poll_report(),
        reply_markup=bot_data.distribution_keyboard,
        parse_mode="Markdown"
    )
    bot_data.last_user_messages[uid]          = [dash]
    bot_data.personal_report_message_id       = dash.message_id
    bot_data.messages_to_delete.setdefault(uid, []).append(dash.message_id)

    await _refresh_menu(uid)                  # переключаем кнопку «📊» → «📊» (без изменений)
    await _delete_trigger(message)


# ╔═══════════════════════════════════════════════════════════════════════════╗
# ║          [11.0] game_details_handler (v2.0 — single-screen fix)          ║
# ╚═══════════════════════════════════════════════════════════════════════════╝
# Показывает детали игры и гарантирует, что в ЛС остаётся ОДНО сообщение.
# version: 2.0 (08.06.2025)

@router.callback_query(lambda c: c.data.startswith("game_details_"))
async def game_details_handler(callback: types.CallbackQuery) -> None:
    user_id  = callback.from_user.id
    deal_id  = int(callback.data.split("_")[-1])

    try:
        # ➊ Чистим предыдущее «окно»
        await delete_previous_private_messages(user_id)

        # ➋ Ищем сделку (в кеше show_games или в активном опросе)
        deal = next(
            (d for d in bot_data.games_by_user.get(user_id, []) if d["id"] == deal_id),
            next((d for d in bot_data.current_poll_deals if d["id"] == deal_id), None)
        )
        if not deal:
            await callback.answer("⚠️ Игра не найдена.", show_alert=True)
            return

        # ➌ Формируем текст
        date_part    = deal["event_datetime"].strftime("%d.%m.%Y")
        time_part    = deal.get("event_time", "—")
        quest        = deal.get("game_name", "—")
        package      = deal.get("package", "—")
        status       = deal.get("status", "—")
        players      = deal.get("players", "—")
        age          = deal.get("age", "—")
        extra        = deal.get("extra_services", "—")
        comment      = deal.get("comment", "—")
        prepay       = deal.get("prepayment", 0)
        leads        = ", ".join(l["name"] for l in deal.get("team_leads", [])) or "—"
        photographer = deal.get("photographer", "—")
        total_budget = deal.get("total_budget", 0)
        to_calc      = deal.get("to_calculate", 0)

        text = "\n".join([
            f"🎮 *Игра*: {quest}",
            f"🎁 *Пакет услуг*: {package}",
            f"🔖 *Статус*: {status}",
            f"📅 *Дата*: {date_part}",
            f"🕒 *Время*: {time_part}",
            f"👥 *Игроки*: {players}",
            f"⚠️ *Возраст*: {age}",
            f"➕ *Доп. услуги*: {extra}",
            f"💬 *Комментарий*: {comment}",
            f"💸 *Предоплата*: {prepay} ₽",
            f"🧑‍🤝‍🧑 *Ведущие*: {leads}",
            f"📷 *Фотограф*: {photographer}",
            f"💰 *Бюджет*: {total_budget} ₽",
            f"🧮 *К расчёту*: {to_calc} ₽",
        ])

        # ➍ Кнопка «Назад»
        kb = InlineKeyboardBuilder()
        kb.button(text="⬅️ Назад к списку", callback_data="back_to_games_list")
        kb.adjust(1)

        sent = await callback.message.answer(text, reply_markup=kb.as_markup(), parse_mode="Markdown")

        # ➎ Сохраняем только ЭТО сообщение как активное
        bot_data.last_user_messages[user_id] = [sent]

        await callback.answer()

    except Exception as e:
        logger.error("[11.0] game_details_handler v2.0: %s", e, exc_info=True)
        await callback.answer("⚠️ Ошибка при загрузке деталей.", show_alert=True)

# ╔═══════════════════════════════════════════════════════════════════════════╗
# ║                   [11.1] back_to_games_list_handler (v1.1)               ║
# ╚═══════════════════════════════════════════════════════════════════════════╝
# «⬅️ Назад к списку» теперь тоже запускает пылесос.
# version: 1.1 (08.06.2025)

@router.callback_query(lambda c: c.data == "back_to_games_list")
async def back_to_games_list_handler(callback: types.CallbackQuery) -> None:
    user_id = callback.from_user.id
    try:
        # 🧹 убираем детали, чтобы остался только новый список
        await delete_previous_private_messages(user_id)

        games = bot_data.games_by_user.get(user_id)
        if not games:
            await callback.answer("😔 Список игр недоступен.", show_alert=True)
            return

        kb = InlineKeyboardBuilder()
        for d in games:
            btn_text = f"🎉 {d['name']} {d['event_time']}"
            kb.button(text=btn_text, callback_data=f"game_details_{d['id']}")
        kb.adjust(1)

        sent = await callback.message.answer(
            "📋 Список игр:\nВыберите игру:", reply_markup=kb.as_markup()
        )

        # сохраняем единственный активный экран
        bot_data.last_user_messages[user_id] = [sent]

        await callback.answer()
    except Exception as e:
        logger.error("[11.1] back_to_games_list_handler: %s", e, exc_info=True)
        await callback.answer("⚠️ Не удалось вернуться к списку.", show_alert=True)


# ╔═══════════════════════════════════════════════════════════════════════════╗
# ║                  [11.2] report_back_handler (⬅️ Назад)                    ║
# ╚═══════════════════════════════════════════════════════════════════════════╝
# Показывает исходный список игр из отчёта, когда пользователь нажимает «Назад»
# version: 1.0 (30.05.2025)

@router.callback_query(lambda c: c.data == "report_back")
async def report_back_handler(callback: types.CallbackQuery) -> None:
    """Возврат из подробного отчёта по игре к списку игр-кнопок."""
    try:
        await callback.message.delete()                 # убираем детальный отчёт
        # перерисовываем «главную» клавиатуру отчёта
        await bot.edit_message_text(
            await generate_poll_report(),
            chat_id=callback.from_user.id,
            message_id=bot_data.personal_report_message_id,
            reply_markup=bot_data.distribution_keyboard,
            parse_mode="Markdown"
        )
        await callback.answer()
    except Exception:
        # если сообщение уже удалено — просто игнорируем
        await callback.answer()

# ╔═══════════════════════════════════════════════════════════════════════════╗
# ║                           [12.0] Клавиатуры                              ║
# ║                                                                           ║
# ╚═══════════════════════════════════════════════════════════════════════════╝
# version: 1.5 (08.06.2025) — кнопка «📋 Создать опрос» → «📊 Отчёт по опросу»
#   • если bot_data.coordination_cycle_active == True, в меню показывается
#     отчёт; иначе — создание опроса.

from typing import List, Optional
from aiogram.types import ReplyKeyboardMarkup, KeyboardButton
from aiogram.utils.keyboard import ReplyKeyboardBuilder   # aiogram 3.x builder

async def get_main_menu(user_id: int) -> Optional[ReplyKeyboardMarkup]:
    """Создаёт главное меню в зависимости от роли и состояния опроса."""
    try:
        user_info = get_user_info(user_id) or {}
        role = user_info.get("role", "")

        btns: List[KeyboardButton] = []

        if role in ACCESS["games"]:
            btns.extend([
                KeyboardButton(text="\U0001F4C5 Новые игры"),
                KeyboardButton(text="\U00002705 Распределённые игры")
            ])

        if role in ACCESS["poll"]:
            if bot_data.coordination_cycle_active:
                # идёт активный опрос → показываем отчёт
                btns.append(KeyboardButton(text="\U0001F4CA Отчёт по опросу"))
            else:
                # опроса нет → можно создать новый
                btns.append(KeyboardButton(text="\U0001F4CB Создать опрос"))

        if not btns:
            logger.warning("[12.0] get_main_menu: Нет доступных кнопок для %d, role=%s",
                           user_id, role)
            return None

        builder = ReplyKeyboardBuilder()
        builder.add(*btns)
        builder.adjust(2)
        return builder.as_markup(resize_keyboard=True)

    except Exception as exc:
        logger.error("[12.0] get_main_menu: Ошибка для %d: %s", user_id, exc, exc_info=True)
        return None

# ╔═══════════════════════════════════════════════════════════════════════════╗
# ║                     [12.1] Клавиатура распределения                       ║
# ╚═══════════════════════════════════════════════════════════════════════════╝
# Описание: единая клавиатура к личному отчёту руководителя
#           («👌 Утвердить», «💾 Сохранить», «🔧 Изменить вручную»)
#           Вызывается из create_poll_handler через get_distribution_keyboard()
# version: 1.0 (30.05.2025)

def get_distribution_keyboard() -> InlineKeyboardMarkup:
    """Возвращает инлайн-клавиатуру для действий над распределением."""
    kb = InlineKeyboardBuilder()
    kb.button(text="👌 Утвердить распределение",
              callback_data="distribute_leaders")
    kb.button(text="💾 Сохранить в AmoCRM",
              callback_data="save_distribution")
    kb.button(text="🔧 Изменить состав вручную",
              callback_data="manual_edit")
    kb.adjust(1)          # каждая кнопка в новой строке
    return kb.as_markup()

# ╔═══════════════════════════════════════════════════════════════════════════╗
# ║                [13.0] generate_poll_report  (v6.5 – 11-06-2025)           ║
# ║  • each user counted максимум в ОДНУ роль (greedy-алгоритм)              ║
# ║  • admin_available + проверка роли сохраняются                           ║
# ╚═══════════════════════════════════════════════════════════════════════════╝
from aiogram.types import InlineKeyboardButton, InlineKeyboardMarkup

def _get_role_cfg(game_name: str) -> dict[str, int]:
    clean = game_name.strip().lower()
    for title, cfg in GAME_ROLE_MAPPING.items():
        if title.lower() == clean:
            return cfg
    return {"main_leaders": 1, "assistants": 0}

def _is_real_admin(uid: int) -> bool:
    role = (get_user_info(uid) or {}).get("role", "").lower()
    return role in {"администратор", "руководитель"}

async def generate_poll_report() -> str:
    if not bot_data.current_poll_deals or not bot_data.responses:
        return "⚠️ Нет активных опросов."

    keyboard: list[list[InlineKeyboardButton]] = []

    # «глобальные» админы (admin_available)
    poll_admins = [
        u for pdata in bot_data.responses.values() for u in pdata["admin_available"]
        if _is_real_admin(u["user_id"])
    ]

    for deal in bot_data.current_poll_deals:
        did        = deal["id"]
        game       = deal["game_name"]
        date_str   = deal["event_datetime"].strftime("%d.%m")
        pkg_lower  = (deal.get("package") or "").strip().lower()

        cfg              = _get_role_cfg(game)
        need_main        = cfg["main_leaders"]
        need_assist      = cfg["assistants"]
        need_admin       = 1 if pkg_lower in {"стандарт", "стандарт+", "премиум", "vip", "вип"} else 0

        # --------- собираем уникальных респондентов --------
        respondents: dict[int, dict] = {}
        for pdata in bot_data.responses.values():
            for u in pdata["deals"].get(did, []):
                respondents[u["user_id"]] = u
        for u in poll_admins:
            respondents.setdefault(u["user_id"], u)

        have_main = have_assist = have_admin = 0
        # greedy-расклад: сначала main, потом assist
        for u in respondents.values():
            if u.get("is_admin_eligible") and have_admin < need_admin:
                have_admin += 1
                continue

            status = await get_user_status_from_svetofor(u["user_id"], game)
            if status == "green":
                if have_main < need_main:
                    have_main += 1
                elif have_assist < need_assist:
                    have_assist += 1
            elif status == "yellow" and have_assist < need_assist:
                have_assist += 1

        ready = (have_main >= need_main and
                 have_assist >= need_assist and
                 have_admin >= need_admin)
        icon = "✅" if ready else "❌"
        keyboard.append([InlineKeyboardButton(
            text=f"{icon} {game} — {date_str}",
            callback_data=f"show_deal_{did}"
        )])

    bot_data.distribution_keyboard = InlineKeyboardMarkup(inline_keyboard=keyboard)
    return "📊 *Опрос создан. Выберите игру:*"

# ╔═══════════════════════════════════════════════════════════════════════════╗
# ║        [13.0.1] show_deal_callback_handler  (v5.11 – 11-06-2025)          ║
# ║  • После клика удаляется и список-сообщение, и старые детали              ║
# ║  • respondents → dict (без дублей)                                        ║
# ║  • Полная совместимость с остальной логикой                               ║
# ╚═══════════════════════════════════════════════════════════════════════════╝
@router.callback_query(lambda c: c.data.startswith("show_deal_"))
async def show_deal_callback_handler(callback: types.CallbackQuery) -> None:
    user_id = callback.from_user.id
    deal_id = int(callback.data.split("_")[-1])

    try:
        # ➊ Удаляем всё старое (списки, детали, «сироты»)
        await delete_previous_private_messages(user_id)

        # ➊.1 Удаляем сам список игр, на котором был клик
        try:
            await callback.message.delete()
        except Exception:
            pass                                     # уже удалён / не наш — игнорируем

        # ➋ Ищем сделку
        deal = next((d for d in bot_data.current_poll_deals if d["id"] == deal_id), None)
        if not deal:
            if callback.id != "refresh":
                await callback.answer("⚠️ Игра не найдена.", show_alert=True)
            return

        # ➌ Заголовок
        game   = deal["game_name"]
        date   = deal["event_datetime"].strftime("%d.%m.%Y")
        time   = deal.get("event_time", "—")
        pkg    = (deal.get("package") or "—").strip()
        pkg_i  = {"компакт": "🎒", "стандарт": "📦", "стандарт+": "📦➕",
                  "премиум": "💎", "vip": "👑", "вип": "👑"}.get(pkg.lower(), "🎁")
        players = parse_players_count(deal.get("players"))

        msgs = [await bot.send_message(
            user_id,
            f"🎮 *{game}*\n📅 {date} · 🕒 {time}\n"
            f"📦 *Пакет:* {pkg_i} {pkg}\n"
            f"👥 *Игроки:* {players or '—'}",
            parse_mode="Markdown"
        )]

        # ➍ Уникальные респонденты -----------------------------------------
        resp: dict[int, dict] = {
            u["user_id"]: u
            for pdata in bot_data.responses.values()
            for u in pdata["deals"].get(deal_id, [])
        }
        # + глобальные админы
        for pdata in bot_data.responses.values():
            for adm in pdata["admin_available"]:
                role = (get_user_info(adm["user_id"]) or {}).get("role", "").lower()
                if role in {"администратор", "руководитель"}:
                    resp.setdefault(adm["user_id"], adm)

        cfg          = _get_role_cfg(game)
        need_main    = cfg["main_leaders"]
        need_assist  = cfg["assistants"]
        need_admin   = 1 if pkg.lower() in {"стандарт", "стандарт+", "премиум", "vip", "вип"} else 0
        used: set[int] = set()

        async def render(title: str, rtype: str, req: int) -> None:
            chosen, alt = [], []
            for u in resp.values():
                if u["user_id"] in used:
                    continue
                status = await get_user_status_from_svetofor(u["user_id"], game)

                if rtype == "main" and status == "green":
                    (chosen if len(chosen) < req else alt).append((u, "🟢"))
                elif rtype == "assist" and status in {"green", "yellow"}:
                    mark = "🟢" if status == "green" else "🟡"
                    (chosen if len(chosen) < req else alt).append((u, mark))
                elif rtype == "admin" and u.get("is_admin_eligible"):
                    (chosen if len(chosen) < req else alt).append((u, "🛡️"))

            icon   = {"main": "🧭", "assist": "🛟", "admin": "🛡️"}[rtype]
            block  = [f"───── {icon} *{title.upper()}* ─────",
                      f"{'✅' if len(chosen) >= req else '❌'} {len(chosen)}/{req}"]
            if not chosen:
                block.append("– —")
            for u, mark in chosen:
                used.add(u["user_id"])
                block.append(f"– {u['first_name']} {u['last_name_initial']} {mark}")

            msgs.append(await bot.send_message(user_id, "\n".join(block), parse_mode="Markdown"))

            if alt:
                kb = InlineKeyboardBuilder()
                for u, mark in alt:
                    kb.button(text=f"{u['first_name']} {u['last_name_initial']} {mark}",
                              callback_data=f"swap_{deal_id}_{rtype}_{u['user_id']}")
                kb.adjust(1)
                msgs.append(await bot.send_message(
                    user_id, "🔁 Альтернатива:", reply_markup=kb.as_markup()
                ))

        await render("Ведущие",   "main",   need_main)
        await render("Помощники", "assist", need_assist)
        await render("Админ",     "admin",  need_admin)

        # ➎ Стажёры ---------------------------------------------------------
        interns = [u for u in resp.values()
                   if u["user_id"] not in used and
                   await get_user_status_from_svetofor(u["user_id"], game) == "red"]
        if interns:
            block = ["───── 👷 *СТАЖЁРЫ* ─────"] + [
                f"– {u['first_name']} {u['last_name_initial']} 🔴" for u in interns
            ]
            msgs.append(await bot.send_message(user_id, "\n".join(block), parse_mode="Markdown"))

        # ➏ «Назад» ---------------------------------------------------------
        kb_back = InlineKeyboardBuilder()
        kb_back.button(text="⬅️ Назад к списку", callback_data="back_to_games_list")
        kb_back.adjust(1)
        msgs.append(await bot.send_message(user_id, "⬅️", reply_markup=kb_back.as_markup()))

        # ➐ Сохраняем для будущего vacuum
        bot_data.last_user_messages[user_id] = msgs
        bot_data.detail_blocks[(user_id, deal_id)] = msgs

        if callback.id != "refresh":
            await callback.answer()

    except Exception as exc:
        logger.error("[13.0.1] show_deal_callback_handler v5.11: %s", exc, exc_info=True)
        if callback.id != "refresh":
            await callback.answer("⚠️ Ошибка при отображении состава.", show_alert=True)

# История изменений:
# v5.11 – 11-06-2025 — удаляем список-сообщение; vacuum теперь честно очищает экран.
# v5.10 – 11-06-2025 — respondents dict + TypeError fix.



# ╔═══════════════════════════════════════════════════════════════════════════╗
# ║                  [13.0.1.1] assign_swap_handler  (v1.3)                  ║
# ╚═══════════════════════════════════════════════════════════════════════════╝

@router.callback_query(lambda c: c.data.startswith("swap_"))
async def assign_swap_handler(callback: types.CallbackQuery) -> None:
    try:
        _, deal_id_str, role_type, new_user_id_str = callback.data.split("_", 3)
        deal_id     = int(deal_id_str)
        new_user_id = int(new_user_id_str)

        deal = next((d for d in bot_data.current_poll_deals if d["id"] == deal_id), None)
        if not deal:
            await callback.answer("⚠️ Игра не найдена.", show_alert=True)
            return

        role_prefix = {"main": "lead", "assist": "assistant", "admin": "admin"}.get(role_type)
        if not role_prefix:
            await callback.answer("⚠️ Не удалось определить тип роли.", show_alert=True)
            return

        dist = bot_data.distribution_cache.setdefault(str(deal_id), {})

        # ищем первый свободный слот нужного типа
        role_key = None
        for i in range(1, 5):
            key = f"{role_prefix}{i}" if role_prefix != "admin" else "admin"
            if key not in dist or not dist[key]:
                role_key = key
                break
        if not role_key:
            await callback.answer("⚠️ Свободная роль не найдена.", show_alert=True)
            return

        user_info = get_user_info(new_user_id)
        if not user_info:
            await callback.answer("⚠️ Пользователь не найден.", show_alert=True)
            return

        name   = f"{user_info['first_name']} {user_info['last_name_initial']}"
        suffix = {"lead": ".1", "assistant": ".Пом", "admin": ".Ад"}.get(role_prefix, "")
        dist[role_key] = f"{name}{suffix}"

        await callback.answer("✅ Назначение обновлено.")
        # перерисовываем экран деталей
        await show_deal_callback_handler(callback)

    except Exception as e:
        logger.error("[13.0.1.1] assign_swap_handler: %s", e, exc_info=True)
        await callback.answer("⚠️ Ошибка при замене участника.", show_alert=True)


# ╔═══════════════════════════════════════════════════════════════════════════╗
# ║                [13.0.1.2] refresh_deal_details  (helper)                 ║
# ╚═══════════════════════════════════════════════════════════════════════════╝
async def refresh_deal_details(user_id: int, deal_id: int) -> None:
    """
    Обновляет содержимое уже открытого экрана деталей игры.
    Используется assign_swap_handler и повторные show_deal вызовы.
    """
    msgs = bot_data.detail_blocks.get((user_id, deal_id))
    if not msgs:
        return  # нечего обновлять

    header_msg = msgs[0]
    # быстро перерисовать: удаляем все сообщения, кроме header
    for m in msgs[1:]:
        try:
            await m.delete()
        except Exception:
            pass
    msgs[:] = msgs[:1]  # оставили только header

    # повторно вызываем show_deal для перерисовки (без мерцания)
    dummy_cb = types.CallbackQuery(
        id="refresh", from_user=types.User(id=user_id, is_bot=False, first_name=""),
        chat_instance="", message=header_msg, data=f"show_deal_{deal_id}"
    )
    await show_deal_callback_handler(dummy_cb)



# ╔═══════════════════════════════════════════════════════════════════════════╗
# ║                   [13.0.2] distribute_leaders_handler                     ║
# ╚═══════════════════════════════════════════════════════════════════════════╝
# Описание: Показывает текущее состояние распределения из кэша
#           (не пересчитывает с нуля, не вызывает create_distribution)
# version: 4.0 (28.05.2025) — читает из distribution_cache

@router.callback_query(lambda c: c.data == "distribute_leaders")
async def distribute_leaders_handler(callback: types.CallbackQuery) -> None:
    user_id = callback.from_user.id
    logger.debug("[13.0.2] distribute_leaders_handler: start for user %d", user_id)

    try:
        if not await has_access(user_id, "poll"):
            await callback.answer("⛔ Нет доступа.", show_alert=True)
            return
        if not bot_data.coordination_cycle_active:
            await callback.answer("⚠️ Нет активного опроса.", show_alert=True)
            return

        if not bot_data.distribution_cache:
            await callback.answer("⚠️ Распределение не выполнено.", show_alert=True)
            return

        report = ["📋 *Предварительное распределение:*"]

        for deal in bot_data.current_poll_deals:
            did = str(deal["id"])
            dist = bot_data.distribution_cache.get(did, {})
            if not dist:
                continue

            report.append(f"\n🎯 *{deal['name']}* — {deal['event_datetime_str']}")

            for role, tag in dist.items():
                emoji = {
                    "lead": "🧭", "assistant": "🛟", "admin": "🛡️", "intern": "👷"
                }.get(role.split("1")[0], "👤")
                txt = tag or "_не назначен_"
                report.append(f"{emoji} {role.capitalize()}: {txt}")

        await callback.message.answer("\n".join(report), parse_mode="Markdown")
        await callback.answer()

        logger.debug("[13.0.2] distribute_leaders_handler: done")

    except Exception as e:
        logger.error("[13.0.2] distribute_leaders_handler: Ошибка: %s", e, exc_info=True)
        await callback.answer("⚠️ Ошибка при показе распределения.", show_alert=True)

# ╔═══════════════════════════════════════════════════════════════════════════╗
# ║            [13.0.3] save_distribution_to_amocrm_handler (fixed)           ║
# ╚═══════════════════════════════════════════════════════════════════════════╝
# Исправлено имя функции update_amocrm_tags + добавлен отчёт об отсутствии данных
# version: 1.1 (30.05.2025)

@router.callback_query(lambda c: c.data == "save_distribution")
async def save_distribution_to_amocrm_handler(callback: types.CallbackQuery) -> None:
    user_id = callback.from_user.id
    logger.debug("[13.0.3] save_distribution_to_amocrm_handler: start for user %d", user_id)

    try:
        # проверка прав
        if not await has_access(user_id, "poll"):
            await callback.answer("⛔ Нет доступа.", show_alert=True)
            return

        # проверка, что распределение уже сформировано
        if not bot_data.distribution_cache:
            await callback.answer("⚠️ Сначала утвердите распределение.", show_alert=True)
            return

        updates: list[str] = []

        for deal in bot_data.current_poll_deals:
            did_str = str(deal["id"])
            dist    = bot_data.distribution_cache.get(did_str, {})
            tags    = [t for t in dist.values() if t]  # только непустые теги

            if not tags:
                updates.append(f"⚠️ {deal['name']} — нет тегов для записи")
                continue

            # сохраняем в AmoCRM
            success = await update_amocrm_tags(deal_id=deal["id"], tags=tags)
            updates.append(f"{'✅' if success else '❌'} {deal['name']}")

        report = "\n".join(updates) if updates else "⚠️ Нет данных для обновления."
        await callback.message.answer(
            f"💾 *Сохранение в AmoCRM:*\n{report}",
            parse_mode="Markdown"
        )
        await callback.answer("Готово.")

        logger.info("[13.0.3] save_distribution_to_amocrm_handler: completed")

    except Exception as e:
        logger.error("[13.0.3] save_distribution_to_amocrm_handler: %s", e, exc_info=True)
        await callback.answer("⚠️ Ошибка при сохранении.", show_alert=True)
# ╔═══════════════════════════════════════════════════════════════════════════╗
# ║        [13.0.4] delete_previous_private_messages  (v3.4 – 12-06-2025)    ║
# ║  • сообщение «Панель управления» больше не трогаем                       ║
# ║  • остальная логика без изменений                                        ║
# ╚═══════════════════════════════════════════════════════════════════════════╝
async def delete_previous_private_messages(user_id: int) -> None:
    """
    Оставляет на экране только «Панель управления», удаляя:
      • last_user_messages
      • detail_blocks
      • orphan-ids
      • личный отчёт руководителя
    """
    # 1️⃣ объекты Message из last_user_messages
    msg_objects: list[types.Message] = bot_data.last_user_messages.pop(user_id, [])

    # 2️⃣ detail_blocks пользователя
    for key in [k for k in list(bot_data.detail_blocks) if k[0] == user_id]:
        msg_objects += bot_data.detail_blocks.pop(key, [])

    # 3️⃣ orphan-ids
    orphan_ids: list[int] = bot_data.messages_to_delete.pop(user_id, [])

    # 4️⃣ персональный отчёт руководителя
    if user_id == bot_data.current_poll_leader and bot_data.personal_report_message_id:
        orphan_ids.append(bot_data.personal_report_message_id)
        bot_data.personal_report_message_id = None

    # 5️⃣ удаляем найденное
    ok = fail = 0
    for m in msg_objects:
        try:
            await m.delete(); ok += 1
        except Exception:
            fail += 1
    for mid in orphan_ids:
        try:
            await bot.delete_message(chat_id=user_id, message_id=mid); ok += 1
        except Exception:
            fail += 1

    logger.debug("[13.0.4] vacuum uid=%d → %d ok | %d fail", user_id, ok, fail)

# ╔═══════════════════════════════════════════════════════════════════════════╗
# ║                        [13.0.5] report_unknown_names                     ║
# ╚═══════════════════════════════════════════════════════════════════════════╝
# Описание: Сообщает о пользователях, не найденных в базе.
# version: 4.9.0 (MasterBot 12.90)

async def report_unknown_names() -> None:
    logger.debug("[13.0.5] report_unknown_names: start")
    try:
        unknown = []
        for data in bot_data.responses.values():
            for deal_id, users in data["deals"].items():
                for u in users:
                    if not get_user_info(u["user_id"]):
                        unknown.append(u["first_name"])
            for u in data["admin_available"] + data["not_available"]:
                if not get_user_info(u["user_id"]):
                    unknown.append(u["first_name"])
        if unknown:
            text = "⚠️ Неизвестные пользователи: " + ", ".join(sorted(set(unknown)))
            await bot.send_message(bot_data.current_poll_leader, text, parse_mode="Markdown")
        logger.debug("[13.0.5] report_unknown_names: done")
    except Exception as e:
        logger.error("[13.0.5] report_unknown_names: Ошибка при сообщении о неизвестных пользователях: %s", e, exc_info=True)


# ╔═══════════════════════════════════════════════════════════════════════════╗
# ║                         [13.2] clear_poll_data                           ║
# ╚═══════════════════════════════════════════════════════════════════════════╝
# Описание: Очищает данные опроса после завершения или по таймауту.
# version: 12.90

async def clear_poll_data(user_id: int) -> None:
    logger.debug("[13.2] clear_poll_data: start for user %d", user_id)
    try:
        bot_data.responses.clear()
        bot_data.current_poll_deals.clear()
        bot_data.distribution_cache.clear()
        bot_data.personal_report_message_id = None
        bot_data.current_poll_leader = None
        bot_data.coordination_cycle_active = False
        bot_data.distribution_keyboard = None
        bot_data.current_event_period = None
        logger.info("[13.2] clear_poll_data: Данные опроса очищены для пользователя %d", user_id)
    except Exception as e:
        logger.error("[13.2] clear_poll_data: Ошибка при очистке данных опроса для пользователя %d: %s", user_id, e, exc_info=True)


# ╔═══════════════════════════════════════════════════════════════════════════╗
# ║                        [13.3] handle_poll_answer  (v2.4 – 11-06-2025)     ║
# ║  • online-индикация набора команды остаётся (detail-refresh)              ║
# ║  • отчёт руководителя теперь ТОЛЬКО один:                                 ║
# ║      – “message is not modified” → считаем успех                          ║
# ║      – при любой другой ошибке старый отчёт удаляется и шлётся новый      ║
# ║      – last_user_messages и personal_report_message_id обновляются        ║
# ╚═══════════════════════════════════════════════════════════════════════════╝
@router.poll_answer()
async def handle_poll_answer(event: types.PollAnswer) -> None:
    uid, poll_id, chosen = event.user.id, event.poll_id, event.option_ids
    logger.debug("[13.3] handle_poll_answer: poll=%s user=%d choices=%s",
                 poll_id, uid, chosen)

    # ——— опрос не наш ————————————————————————————————————————————————
    if poll_id not in bot_data.responses:
        return
    data = bot_data.responses[poll_id]

    # ——— 1. убираем старые ответы пользователя ————————————————
    for lst in data["deals"].values():
        lst[:] = [u for u in lst if u["user_id"] != uid]
    data["not_available"][:]   = [u for u in data["not_available"]   if u["user_id"] != uid]
    data["admin_available"][:] = [u for u in data["admin_available"] if u["user_id"] != uid]

    # ——— 2. добавляем новые выборы ————————————————————————————————
    ui   = get_user_info(uid) or {}
    base = {
        "user_id": uid,
        "first_name": ui.get("first_name", ""),
        "last_name_initial": ui.get("last_name_initial", ""),
        "is_admin_eligible": False
    }
    num_games   = len(data["deal_indices"])
    impacted: set[int] = set()
    refresh_all = False

    for idx in chosen:
        if idx < num_games:                               # конкретная игра
            did = data["deal_indices"][idx]
            data["deals"][did].append(base.copy())
            impacted.add(did)
        elif idx == num_games:                            # 🚫
            data["not_available"].append(base.copy())
        elif idx == num_games + 1:                        # 🛡️
            adm = base.copy(); adm["is_admin_eligible"] = True
            data["admin_available"].append(adm)
            refresh_all = True

    # если пользователь стал «🛡️» – убираем его из списков игр (чтобы не дублировался)
    if refresh_all:
        for lst in data["deals"].values():
            lst[:] = [u for u in lst if not u.get("is_admin_eligible")]

    # ——— 3. обновляем / пересоздаём отчёт руководителя ——————————————
    async def _sync_leader_report() -> None:
        new_text = await generate_poll_report()
        leader   = bot_data.current_poll_leader
        msg_id   = bot_data.personal_report_message_id

        if not leader:                                   # на всякий
            return

        try:
            await bot.edit_message_text(
                new_text, chat_id=leader, message_id=msg_id,
                parse_mode="Markdown", reply_markup=bot_data.distribution_keyboard
            )
            return                                        # 🎉 успешно отредактировали
        except TelegramBadRequest as e:
            if "message is not modified" in str(e):
                logger.debug("[13.3] report unchanged → skip")
                return                                    # текст тот же – ничего не делаем
            # иначе: сообщение пропало / равных прав нет → пришлём новое
            logger.warning("[13.3] report edit failed: %s — recreating", e)

        # удаляем старый отчёт, если он ещё существует
        if msg_id:
            try:
                await bot.delete_message(chat_id=leader, message_id=msg_id)
            except Exception:
                pass

        sent = await bot.send_message(
            leader, new_text, parse_mode="Markdown",
            reply_markup=bot_data.distribution_keyboard
        )
        bot_data.personal_report_message_id = sent.message_id
        bot_data.last_user_messages[leader] = [sent]      # vacuum увидит актуальный отчёт

    try:
        await _sync_leader_report()
    except Exception as e:
        logger.error("[13.3] leader report sync error: %s", e, exc_info=True)

    # ——— 4. live-refresh detail-экранов ——————————————————————————
    try:
        if refresh_all:
            impacted = {d["id"] for d in bot_data.current_poll_deals}
        tasks = [
            refresh_deal_details(u_id, d_id)
            for (u_id, d_id) in list(bot_data.detail_blocks)
            if d_id in impacted
        ]
        if tasks:
            await asyncio.gather(*tasks, return_exceptions=True)
            logger.debug("[13.3] %d detail views refreshed", len(tasks))
    except Exception as e:
        logger.error("[13.3] detail refresh error: %s", e, exc_info=True)

# История изменений:
# v2.4 – 11-06-2025 — один отчёт без дублей; online-refresh сохранён.
# v2.3 – прочие фиксы.


# ╔═══════════════════════════════════════════════════════════════════════════╗
# ║                         [13.4] Редактирование состава                     ║
# ╚═══════════════════════════════════════════════════════════════════════════╝
# Описание: Упрощённое редактирование распределения по ролям
# version: 1.0 (27.05.2025) — компактное меню на одну игру

@router.callback_query(lambda c: c.data == "manual_edit")
async def manual_edit_menu(callback: types.CallbackQuery) -> None:
    """Показывает список игр с кнопками редактирования состава."""
    try:
        kb = InlineKeyboardBuilder()
        for deal in bot_data.current_poll_deals:
            name = deal["name"]
            date = deal["event_datetime"].strftime("%d.%m")
            kb.button(text=f"✏️ {name} — {date}", callback_data=f"edit_compact_{deal['id']}")
        kb.adjust(1)

        await callback.message.answer("🛠 Выберите игру для редактирования состава:", reply_markup=kb.as_markup())
        await callback.answer()
    except Exception as e:
        logger.error("[13.4] manual_edit_menu: %s", e, exc_info=True)
        await callback.answer("⚠️ Ошибка отображения игр.", show_alert=True)


@router.callback_query(lambda c: c.data.startswith("edit_compact_"))
async def edit_compact_roles(callback: types.CallbackQuery) -> None:
    """Показывает состав ролей на одну игру, каждая роль — отдельная кнопка."""
    try:
        deal_id = int(callback.data.split("_")[-1])
        deal = next((d for d in bot_data.current_poll_deals if d["id"] == deal_id), None)
        if not deal:
            await callback.answer("⚠️ Игра не найдена.", show_alert=True)
            return

        roles = bot_data.distribution_cache.get(str(deal_id), {})
        kb = InlineKeyboardBuilder()

        for role, name in roles.items():
            btn_text = f"{role.capitalize()}: {name or '—'}"
            kb.button(text=btn_text, callback_data=f"select_user_{deal_id}_{role}")
        kb.adjust(1)

        await callback.message.answer(f"🛠 Состав для *{deal['name']}*:", reply_markup=kb.as_markup(), parse_mode="Markdown")
        await callback.answer()

    except Exception as e:
        logger.error("[13.4] edit_compact_roles: %s", e, exc_info=True)
        await callback.answer("⚠️ Ошибка при отображении ролей.", show_alert=True)


@router.callback_query(lambda c: c.data.startswith("select_user_"))
async def select_user_for_role(callback: types.CallbackQuery) -> None:
    """Показывает кандидатов на конкретную роль в игре."""
    try:
        _, deal_id, role = callback.data.split("_", 2)
        deal_id = int(deal_id)
        deal = next((d for d in bot_data.current_poll_deals if d["id"] == deal_id), None)
        if not deal:
            await callback.answer("⚠️ Игра не найдена.", show_alert=True)
            return

        candidates = []
        for p in bot_data.responses.values():
            candidates += p["deals"].get(deal_id, [])

        # фильтруем по роли
        filtered = []
        for u in candidates:
            status = await get_user_status_from_svetofor(u["user_id"], deal["game_name"])
            if role.startswith("lead") and status == "green":
                filtered.append(u)
            elif role.startswith("assistant") and status in ("green", "yellow"):
                filtered.append(u)
            elif role == "admin" and u.get("is_admin_eligible"):
                filtered.append(u)
            elif role == "intern" and status == "red":
                filtered.append(u)

        kb = InlineKeyboardBuilder()
        for u in filtered:
            name = f"{u['first_name']} {u['last_name_initial']}"
            kb.button(text=name, callback_data=f"assign_{deal_id}_{role}_{u['user_id']}")
        kb.button(text="⛔ Убрать назначение", callback_data=f"assign_{deal_id}_{role}_none")
        kb.adjust(1)

        await callback.message.answer(f"👤 Кандидаты на роль `{role}` в *{deal['name']}*:", reply_markup=kb.as_markup(), parse_mode="Markdown")
        await callback.answer()

    except Exception as e:
        logger.error("[13.4] select_user_for_role: %s", e, exc_info=True)
        await callback.answer("⚠️ Ошибка при выводе кандидатов.", show_alert=True)


@router.callback_query(lambda c: c.data.startswith("assign_"))
async def assign_user_to_role(callback: types.CallbackQuery) -> None:
    """Назначает пользователя на роль или снимает назначение."""
    try:
        _, deal_id, role, user_id = callback.data.split("_", 3)
        deal_id = str(deal_id)
        user_id = None if user_id == "none" else int(user_id)

        if deal_id not in bot_data.distribution_cache:
            bot_data.distribution_cache[deal_id] = {}

        if user_id:
            info = get_user_info(user_id)
            name = f"{info['first_name']} {info['last_name_initial']}" if info else "??"
            suffix = {
                "lead": ".1", "assistant": ".Пом", "admin": ".Ад", "intern": ".Стаж"
            }.get(role.split("1")[0], "")
            tag = f"{name}{suffix}"
        else:
            tag = ""

        bot_data.distribution_cache[deal_id][role] = tag
        await callback.answer("✅ Назначение сохранено.")
        await edit_compact_roles(callback)  # перерисовать меню

    except Exception as e:
        logger.error("[13.4] assign_user_to_role: %s", e, exc_info=True)
        await callback.answer("⚠️ Ошибка при назначении.", show_alert=True)

# ════════════════════════════════════════════════════════════════════════════
# version: 1.0 (27.05.2025)
# История изменений:
# - 1.0: Упрощённый редактор состава по ролям через инлайн-кнопки без вложенных меню


# ╔═══════════════════════════════════════════════════════════════════════════╗
# ║                                                                           ║
# ║                   [15.0] Обновление Google Sheets                         ║
# ║                                                                           ║
# ╚═══════════════════════════════════════════════════════════════════════════╝
# Описание: Функции для записи результатов распределения в Google Sheets.
# version: 1.1

async def create_distribution_table(spreadsheet_id: str, deals: List[Dict], distribution: Dict) -> None:
    """Создаёт таблицу распределения в Google Sheets.

    Args:
        spreadsheet_id: ID таблицы Google Sheets.
        deals: Список сделок.
        distribution: Словарь распределения.
    """
    try:
        creds = Credentials.from_service_account_file(GOOGLE_CREDENTIALS_FILE, scopes=GOOGLE_SHEETS_SCOPES)
        client = gspread.authorize(creds)
        spreadsheet = client.open_by_key(spreadsheet_id)
        sheet = spreadsheet.worksheet(DISTRIBUTION_SPREADSHEET_NAME)

        headers = ["ID сделки", "Название", "Дата и время", "Квест", "Ведущий 1", "Ведущий 2", "Помощник 1", "Помощник 2", "Администратор"]
        data = [headers]

        for deal in deals:
            deal_id = str(deal["id"])
            dist = distribution.get(deal_id, {})
            row = [
                deal["id"],
                deal["name"],
                deal["event_datetime_str"],
                deal["game_name"],
                dist.get("lead1", ""),
                dist.get("lead2", ""),
                dist.get("assistant1", ""),
                dist.get("assistant2", ""),
                dist.get("admin", "")
            ]
            data.append(row)

        sheet.clear()
        sheet.update("A1", data)
        logger.info("[15.0] create_distribution_table: Таблица распределения обновлена, строк: %d", len(data))
    except Exception as e:
        logger.error("[15.0] create_distribution_table: Ошибка обновления таблицы: %s", e, exc_info=True)

# version: 1.1
# История изменений:
# - 1.0: Базовая функция для Google Sheets.
# - 1.1 (11.05.2025): Улучшено логирование, добавлены проверки.


# ╔═══════════════════════════════════════════════════════════════════════════╗
# ║                     [16.0] show_games (v3.2, single-screen)              ║
# ╚═══════════════════════════════════════════════════════════════════════════╝
# После показа списка игр в last_user_messages остаётся ровно один объект.
# version: 3.2 (08.06.2025)
from contextlib import asynccontextmanager
import asyncio

_user_locks: dict[int, asyncio.Lock] = {}

@asynccontextmanager
async def user_lock(uid: int):
    """Пер-пользовательский асинхронный замок,
    чтобы не было гонок при одновременных кликах."""
    lock = _user_locks.setdefault(uid, asyncio.Lock())
    await lock.acquire()
    try:
        yield
    finally:
        lock.release()

async def show_games(
    message: types.Message,
    user_id: int,
    status_ids: list[str],
    title: str,
    only_unassigned: bool | None = None,
) -> None:
    async with user_lock(user_id):
        logger.debug("[16.0] === show_games START for %d ===", user_id)

        # 0. чистим предыдущий экран
        await delete_previous_private_messages(user_id)

        # 1. сделки
        spread_id = bot_data.config.get("svetofor_spread_id")
        if not spread_id:
            await message.answer("⚠️ Не указан ID таблицы «Светофор».")
            logger.error("[16.0] show_games: нет spread_id")
            return

        deals = await get_amocrm_deals(spread_id)
        now   = datetime.now(tz=MSK_TZ)

        if only_unassigned is None:
            only_unassigned = (status_ids == NEW_GAMES_STATUS_IDS)

        filtered = [
            d for d in deals
            if d["status_id"] in status_ids
               and d["event_datetime"] >= now
               and (not only_unassigned or not d["team_leads"])
        ]

        if not filtered:
            await message.answer(f"{title}\n😔 Подходящих игр нет.")
            return

        filtered.sort(key=lambda d: d["event_datetime"])
        filtered = filtered[:20]

        # 2. клавиатура
        kb = InlineKeyboardBuilder()
        for d in filtered:
            date  = d["event_datetime"].strftime("%d.%m")
            extra = d.get("package") or d.get("extra_services") or ""
            extra = f" · {extra}" if extra and extra != "Не указано" else ""
            kb.button(
                text=f"🎉 {d['name']} — {date}{extra}",
                callback_data=f"game_details_{d['id']}"
            )
        kb.adjust(1)

        # 3. отправляем и оставляем ОДНО сообщение в истории
        sent = await message.answer(f"{title}\nВыберите игру:", reply_markup=kb.as_markup())

        bot_data.last_user_messages[user_id] = [sent]
        bot_data.games_by_user[user_id]      = filtered

        logger.info("[16.0] show_games DONE for %d (sent %d games)",
                    user_id, len(filtered))


# ╔═══════════════════════════════════════════════════════════════════════════╗
# ║                                                                           ║
# ║                      [17.0] Проверки доступа                              ║
# ║                                                                           ║
# ╚═══════════════════════════════════════════════════════════════════════════╝
# Описание: Функции для проверки прав доступа пользователей.
# version: 1.1

async def has_access(user_id: int, access_type: str) -> bool:
    """Проверяет, имеет ли пользователь доступ к функции.

    Args:
        user_id: ID пользователя.
        access_type: Тип доступа (games, poll, distribution).

    Returns:
        bool: True, если доступ есть.
    """
    try:
        user_info = get_user_info(user_id)
        if not user_info:
            logger.warning("[17.0] has_access: Пользователь %d не найден", user_id)
            return False

        role = user_info.get("role", "")
        has_access = role in ACCESS.get(access_type, [])
        logger.debug("[17.0] has_access: Пользователь %d (%s) запросил %s, доступ: %s", user_id, role, access_type, has_access)
        return has_access
    except Exception as e:
        logger.error("[17.0] has_access: Ошибка для пользователя %d, тип %s: %s", user_id, access_type, e, exc_info=True)
        return False

async def is_bot_admin(chat_id: int) -> bool:
    """Проверяет, является ли бот администратором чата.

    Args:
        chat_id: ID чата.

    Returns:
        bool: True, если бот админ.
    """
    try:
        chat_member = await bot.get_chat_member(chat_id, bot.id)
        is_admin = chat_member.status in ["administrator", "creator"]
        logger.debug("[17.0] is_bot_admin: Бот в чате %d, статус: %s, админ: %s", chat_id, chat_member.status, is_admin)
        return is_admin
    except TelegramAPIError as e:
        logger.error("[17.0] is_bot_admin: Ошибка проверки статуса в чате %d: %s", chat_id, e, exc_info=True)
        return False

# version: 1.1
# История изменений:
# - 1.0: Базовые проверки доступа.
# - 1.1 (11.05.2025): Улучшено логирование, добавлены проверки.
# ╔═══════════════════════════════════════════════════════════════════════════╗
# ║                                                                           ║
# ║                      [18.0] Инициализация бота                            ║
# ║                                                                           ║
# ╚═══════════════════════════════════════════════════════════════════════════╝
# Описание: Загрузка конфигурации и токенов, admin_chat_id, гарантия наличия
#           LEADER_ID в БД, логирование кастом-полей, генерация маппинга и запуск планировщика.
# version: 1.4  (17.05.2025)  ← добавлено логирование AMOCRM_FIELDS

async def on_startup() -> None:
    """Действия при запуске бота."""
    try:
        # загрузка конфигурации
        bot_data.config = await load_json(CONFIG_FILE)
        logger.info("[18.0] on_startup: Конфигурация загружена из %s", CONFIG_FILE)

        # загрузка токенов
        bot_data.tokens = await load_json(TOKENS_FILE)
        logger.info("[18.0] on_startup: Токены загружены из %s", TOKENS_FILE)

        # логирование используемых кастом-полей из AMOCRM_FIELDS
        logger.info("[18.0] Используемые кастом-поля AmoCRM:")
        for name, fid in AMOCRM_FIELDS.items():
            logger.info("    %s → %s", name, fid)

        # получение admin_chat_id
        if os.path.exists(CHAT_ID_FILE):
            with open(CHAT_ID_FILE, "r", encoding="utf-8") as f:
                bot_data.admin_chat_id = json.load(f).get("admin_chat_id")
            logger.info("[18.0] on_startup: admin_chat_id=%s", bot_data.admin_chat_id)
        else:
            logger.warning("[18.0] on_startup: файл %s не найден", CHAT_ID_FILE)

        # ── гарантия LEADER_ID в checklists.db ───────────────────────────────
        import sqlite3
        db_path = os.path.join(BASE_DIR, "checklists.db")
        conn = sqlite3.connect(db_path)
        cur = conn.cursor()
        cur.execute(
            "CREATE TABLE IF NOT EXISTS users ("
            "user_id INTEGER PRIMARY KEY, first_name TEXT, last_name TEXT, role TEXT, scenario_access TEXT)"
        )
        cur.execute(
            "INSERT OR IGNORE INTO users(user_id, first_name, last_name, role) "
            "VALUES (?, '', '', 'руководитель')",
            (LEADER_ID,)
        )
        conn.commit()
        conn.close()
        logger.info("[18.0] on_startup: LEADER_ID %d гарантирован в таблице users", LEADER_ID)
        # ─────────────────────────────────────────────────────────────────────

        # генерация имени-маппинга pipeline и статусов
        await generate_name_mapping()
        logger.info("[18.0] on_startup: Генерация маппинга завершена")

    except Exception as e:
        logger.error("[18.0] on_startup: критическая ошибка: %s", e, exc_info=True)
        raise

async def main() -> None:
    """Точка входа в приложение."""
    try:
        global bot, scheduler
        bot = Bot(token=API_TOKEN, default=DefaultBotProperties(parse_mode="Markdown"))
        dp = Dispatcher()
        scheduler = AsyncIOScheduler(timezone=MSK_TZ)

        dp.include_router(router)
        dp.startup.register(on_startup)
        scheduler.start()

        logger.info("[18.0] main: Бот запущен, версия %s", VERSION)
        await dp.start_polling(bot)
    except Exception as e:
        logger.critical("[18.0] main: Критическая ошибка: %s", e, exc_info=True)
        raise

if __name__ == "__main__":
    asyncio.run(main())

# ────────────────────────────────────────────────────────────────────────────
# История изменений:
# - 1.0 (??.05.2025): базовая инициализация
# - 1.1 (11.05.2025): логи и загрузка chat_id
# - 1.2 (12.05.2025): планировщик с MSK_TZ
# - 1.3 (13.05.2025): вставка LEADER_ID в БД users
# - 1.4 (17.05.2025): логирование AMOCRM_FIELDS перед стартом


# ████████████████████████████████████████████████████████████████████████████
# █                                                                         █
# █                         Конец MasterBot 12.92                            █
# █                                                                         █
# ████████████████████████████████████████████████████████████████████████████
