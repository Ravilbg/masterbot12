
# ████████████████████████████████████████████████████████████████████████████
# █                                                                         █
# █                           MasterBot 12.92                               █
# █                                                                         █
# ████████████████████████████████████████████████████████████████████████████
# Описание: Telegram-бот для управления распределением ведущих на квесты.
# Основной функционал:
# - Загрузка сделок из AmoCRM с фильтрацией по статусам и датам.
# - Отображение новых и распределённых игр.
# - Создание Telegram-опросов для выбора ведущих.
# - Формирование отчётов по опросам и распределению.
# - Обновление AmoCRM и Google Sheets с результатами распределения.
# Версия: 12.92
# Дата: 13.05.2025

import asyncio
import json
import logging
import os
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pytz
from aiogram import Bot, Dispatcher, Router, types
from aiogram.exceptions import TelegramAPIError
from aiogram.filters import Command, CommandStart
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton, ReplyKeyboardMarkup, KeyboardButton
from aiogram.utils.keyboard import InlineKeyboardBuilder
from aiogram.client.bot import DefaultBotProperties
from apscheduler.schedulers.asyncio import AsyncIOScheduler
import gspread
from google.oauth2.service_account import Credentials
import aiohttp
from logging.handlers import RotatingFileHandler

# ─────────────────────────────────────────────────────────────────────────────
# Форвард-декларация, чтобы Pylance видел get_distribution_keyboard
def get_distribution_keyboard() -> InlineKeyboardMarkup:
    """Заглушка для IDE; реальная функция определяется ниже."""
    pass
# ─────────────────────────────────────────────────────────────────────────────


# ╔═══════════════════════════════════════════════════════════════════════════╗
# ║                                                                           ║
# ║                       [1.0] Настройка логирования                         ║
# ║                                                                           ║
# ╚═══════════════════════════════════════════════════════════════════════════╝
# Описание: Инициализация системы логирования для вывода в консоль и файл с улучшенной детализацией.
# version: 1.2

LOG_DIR = os.path.join(os.path.dirname(os.path.abspath(__file__)), "logs")
os.makedirs(LOG_DIR, exist_ok=True)

logging.basicConfig(
    level=logging.DEBUG,
    format="%(asctime)s [%(levelname)s] [%(name)s] [%(filename)s:%(lineno)d] %(message)s",
    handlers=[
        RotatingFileHandler(
            os.path.join(LOG_DIR, "masterbot.log"),
            maxBytes=10 * 1024 * 1024,  # 10 MB
            backupCount=5,
            encoding="utf-8"
        ),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

# version: 1.2
# История изменений:
# - 1.0: Базовая настройка логирования.
# - 1.1 (11.05.2025): Добавлено указание раздела в сообщениях логов.
# - 1.2 (13.05.2025): Добавлена папка logs, улучшена структура хранения логов.

# ╔═══════════════════════════════════════════════════════════════════════════╗
# ║                                                                           ║
# ║                       [2.0] Конфигурация и константы                      ║
# ║                                                                           ║
# ╚═══════════════════════════════════════════════════════════════════════════╝
# Описание: Определяет параметры бота, пути к файлам, токены и настройки.
# version: 1.13

# Параметры бота
VERSION = "MasterBot 12.92"
CURRENT_YEAR = datetime.now().year
SPREADSHEET_NAME = f"Рабочие таблицы {CURRENT_YEAR}"
GOOGLE_API_RATE_LIMIT_SECONDS = 180
DATE_FILTER_THRESHOLD = timedelta(days=30)
POLL_DURATION = timedelta(hours=24)
CACHE_LIFETIME = timedelta(minutes=5)

# Токены и идентификаторы
API_TOKEN = "7637424219:AAHXYNXHrRNZ1XwNbLx7ieBTZtafe6pmkYo"
LEADER_ID = os.getenv("MASTERBOT_LEADER_ID", "1018880781")

if not API_TOKEN or not isinstance(API_TOKEN, str):
    logger.critical("[2.0] API_TOKEN не задан или не является строкой")
    raise SystemExit(1)
logger.info("[2.0] API_TOKEN успешно загружен")

try:
    LEADER_ID = int(LEADER_ID)
except (ValueError, TypeError):
    logger.error("[2.0] MASTERBOT_LEADER_ID должен быть числом, получено: %s", LEADER_ID)
    raise SystemExit(1)

# Пути к файлам
BASE_DIR = os.path.dirname(os.path.abspath(__file__))
LOG_FILE = os.path.join(BASE_DIR, "logs", "masterbot.log")
CHAT_ID_FILE = os.path.join(BASE_DIR, "chat_id.json")
MASTERBOT_DB = os.path.join(BASE_DIR, "masterbot.db")
CONFIG_FILE = os.path.join(BASE_DIR, "config.json")
TOKENS_FILE = os.path.join(BASE_DIR, "tokens.json")

# Учетные данные Google Sheets
GOOGLE_CREDENTIALS_FILE = os.getenv("GOOGLE_CREDENTIALS_PATH")
if not GOOGLE_CREDENTIALS_FILE:
    possible_files = [
        "svetofor-credentials.json",
        "service-account-key.json",
        "credentials.json"
    ]
    for fname in possible_files:
        candidate = os.path.join(BASE_DIR, fname)
        if os.path.exists(candidate):
            GOOGLE_CREDENTIALS_FILE = candidate
            logger.info("[2.0] Найден файл учетных данных Google Sheets: %s", GOOGLE_CREDENTIALS_FILE)
            break

if GOOGLE_CREDENTIALS_FILE and os.path.exists(GOOGLE_CREDENTIALS_FILE):
    try:
        with open(GOOGLE_CREDENTIALS_FILE, 'r', encoding='utf-8') as f:
            creds_data = json.load(f)
            client_email = creds_data.get("client_email", "не указан")
            logger.info("[2.0] Учетные данные Google Sheets загружены: client_email=%s", client_email)
    except (json.JSONDecodeError, KeyError) as e:
        logger.error("[2.0] Ошибка чтения файла учетных данных Google Sheets: %s", e, exc_info=True)
        GOOGLE_CREDENTIALS_FILE = None
else:
    GOOGLE_CREDENTIALS_FILE = os.path.join(BASE_DIR, "svetofor-credentials.json")
    logger.warning(
        "[2.0] Файл учетных данных Google Sheets не найден: %s. Функции Google Sheets будут недоступны.",
        GOOGLE_CREDENTIALS_FILE
    )

# Константы
SVETOFOR_SHEET = "Светофор"
DISTRIBUTION_SPREADSHEET_NAME = "Сводная таблица распределения"
ALLOWED_STATUSES = ["Бронь", "Закрытие сделки", "Предварительная заявка"]
ALLOWED_STATUS_IDS = ["18913933", "18960415", "18913930"]
NEW_GAMES_STATUS_IDS = ["18913930", "18913933"]
SUCCESSFUL_STATUS_ID = "18960415"
DATE_FILTER_DAYS = 30
PREPAYMENT_FIELD_ID = None
PACKAGE_FIELD_ID = "71673"
MSK_TZ = pytz.timezone("Europe/Moscow")
GOOGLE_SHEETS_SCOPES = [
    "https://www.googleapis.com/auth/spreadsheets",
    "https://www.googleapis.com/auth/drive"
]

# Права доступа
ACCESS = {
    "games": ["руководитель", "администратор", "ведущий", "ведущий новичок"],
    "poll": ["руководитель", "администратор"],
    "distribution": ["руководитель", "администратор"],
}

# Отображение дней недели
WEEKDAYS = {
    "Monday": "Пн", "Tuesday": "Вт", "Wednesday": "Ср", "Thursday": "Чт",
    "Friday": "Пт", "Saturday": "Сб", "Sunday": "Вск",
}

# Роли для игр
GAME_ROLE_MAPPING = {
    "Петля времени": {"main_leaders": 1, "assistants": 1},
    "Хранители волшебства": {"main_leaders": 1, "assistants": 1},
    "Время приключений": {"main_leaders": 1, "assistants": 2},
    "Кланы Нью-Йорка": {"main_leaders": 1, "assistants": 3},
    "Коллекционер игр": {"main_leaders": 1, "assistants": 1},
    "Бермудский треугольник": {"main_leaders": 1, "assistants": 3},
    "Старый дом": {"main_leaders": 1, "assistants": 1},
    "Цветочная башня": {"main_leaders": 2, "assistants": 0}
}


AMOCRM_FIELDS = {
    "event_date":     "87751",    # Дата
    "event_time":     "88565",    # время
    "game_name":      "87791",    # Квест
    "age":            "899511",   # Возраст игроков
    "extra_services": "452955",   # Дополнительно (Пиньята в подарок)
    "comment":        "87811",    # Комментарий
    "prepayment":     "100407",   # Предоплата
    "team_leads":     "88567",    # Ведущие
    "photographer":   "87813",    # Фотограф
    "players":        "71635",    # Количество игроков
    "package":        "71673",    # Пакет услуг
}

# version: 1.13
# История изменений:
# - 1.0: Исходная конфигурация.
# - 1.2: Улучшены проверки токена.
# - 1.3: Добавлена константа для сводной таблицы.
# - 1.4: Исправлен токен Telegram-бота, добавлена валидация токена.
# - 1.5: Перемещена настройка логирования для устранения NameError.
# - 1.6: Добавлена проверка существования файла учетных данных.
# - 1.7: Добавлена поддержка GOOGLE_CREDENTIALS_PATH.
# - 1.8: Добавлен поиск файлов учетных данных по типичным именам.
# - 1.9: Добавлено логирование client_email для диагностики.
# - 1.10: Изменён поиск файла учетных данных, добавлено имя svetofor-credentials.json.
# - 1.11: Исправлена ошибка с отступами в цикле for.
# - 1.12 (12.05.2025): API_TOKEN прописан в коде, добавлены MSK_TZ, GAME_ROLE_MAPPING, AMOCRM_FIELDS, улучшено логирование.
# - 1.13 (13.05.2025): Обновлены пути к файлам логов, добавлена папка logs.

# ╔═══════════════════════════════════════════════════════════════════════════╗
# ║                                                                           ║
# ║                       [3.0] Глобальные объекты                            ║
# ║                                                                           ║
# ╚═══════════════════════════════════════════════════════════════════════════╝
# Описание: Определение глобального объекта bot_data для хранения состояния.
# version: 1.2  (17.05.2025)  ← Добавлено games_by_user

class BotData:
    """Класс для хранения состояния бота."""
    def __init__(self):
        self.config: Dict = {}
        self.tokens: Dict = {}
        self.admin_chat_id: Optional[int] = None
        self.svetofor_spreadsheet_id: Optional[str] = None
        self.responses: Dict = {}
        self.current_poll_deals: List[Dict] = []
        self.distribution_cache: Dict = {}
        self.personal_report_message_id: Optional[int] = None
        self.current_poll_leader: Optional[int] = None
        self.coordination_cycle_active: bool = False
        self.distribution_keyboard: Optional[InlineKeyboardMarkup] = None
        self.current_event_period: Optional[List[datetime]] = None
        self.last_event_period: Optional[List[datetime]] = None
        self.pipeline_mapping: Dict = {}
        self.deals_cache: Dict = {}
        self.messages_to_delete: Dict[int, List[int]] = {}
        # 🆕 запоминаем списки игр, показанные каждому пользователю
        self.games_by_user: Dict[int, List[Dict]] = {}

bot_data = BotData()

# version‑history:
# - 1.0: базовая структура
# - 1.1 (11.05.2025): добавлены deals_cache, messages_to_delete
# - 1.2 (17.05.2025): games_by_user для корректной работы деталей


# ╔═══════════════════════════════════════════════════════════════════════════╗
# ║                                                                           ║
# ║                           [4.0] Утилиты                                   ║
# ║                                                                           ║
# ╚═══════════════════════════════════════════════════════════════════════════╝
# Описание: Вспомогательные функции для работы с данными.
# version: 1.1

def parse_players_count(players: Any) -> int:
    """Извлекает количество игроков из строки.

    Args:
        players: Значение поля players (строка, число или None).

    Returns:
        int: Количество игроков или 0 при ошибке.
    """
    try:
        if not players:
            return 0
        players_str = str(players).strip()
        if "-" in players_str:
            return int(players_str.split("-")[-1].strip())
        return int(players_str)
    except (ValueError, TypeError) as e:
        logger.warning("[4.0] parse_players_count: Некорректное значение players=%s: %s", players, e)
        return 0

async def load_json(file_path: str) -> Dict:
    """Загружает JSON-файл.

    Args:
        file_path: Путь к файлу.

    Returns:
        Dict: Данные из файла.

    Raises:
        FileNotFoundError: Если файл не найден.
        json.JSONDecodeError: Если файл содержит некорректный JSON.
    """
    if not os.path.exists(file_path):
        logger.error("[4.0] load_json: Файл %s не найден", file_path)
        raise FileNotFoundError(f"Файл {file_path} не найден")
    try:
        with open(file_path, "r", encoding="utf-8") as f:
            data = json.load(f)
            logger.debug("[4.0] load_json: Успешно загружен файл %s", file_path)
            return data
    except json.JSONDecodeError as e:
        logger.error("[4.0] load_json: Ошибка декодирования JSON в %s: %s", file_path, e)
        raise

async def save_json(file_path: str, data: Dict) -> bool:
    """Сохраняет данные в JSON-файл.

    Args:
        file_path: Путь к файлу.
        data: Данные для сохранения.

    Returns:
        bool: Успешность операции.
    """
    try:
        with open(file_path, "w", encoding="utf-8") as f:
            json.dump(data, f, indent=2, ensure_ascii=False)
        logger.debug("[4.0] save_json: Данные сохранены в %s", file_path)
        return True
    except Exception as e:
        logger.error("[4.0] save_json: Ошибка сохранения %s: %s", file_path, e, exc_info=True)
        return False

# version: 1.1
# История изменений:
# - 1.0: Базовые утилиты.
# - 1.1 (11.05.2025): Добавлено логирование с указанием раздела.

# ╔═══════════════════════════════════════════════════════════════════════════╗
# ║                   [5.0] Работа с Google Sheets                           ║
# ╚═══════════════════════════════════════════════════════════════════════════╝
# Описание: Читает лист «Светофор» из Google Sheets, кешируя метаданные и
#          данные, и возвращает для пользователя статус по цвету ячейки.
# version: 1.8 — единоразовая загрузка includeGridData, case-insensitive заголовки

from typing import Optional
import gspread
from google.oauth2.service_account import Credentials
from googleapiclient.discovery import build

# модуль-уровневый кеш
_svetofor_cache: dict = {
    "sheet": None,           # gspread.Worksheet
    "service": None,         # Google Sheets API client
    "spreadsheet_id": None,
    "rows": None,            # list[rowData]
    "headers": None,         # list[str] заголовки первой строки
}

def _init_svetofor() -> None:
    """Инициализирует sheet, service и spreadsheet_id один раз."""
    if _svetofor_cache["sheet"] is None:
        sid = bot_data.config.get("svetofor_spread_id")
        if not sid:
            raise RuntimeError("[5.0] _init_svetofor: 'svetofor_spread_id' не задан")
        creds = Credentials.from_service_account_file(
            GOOGLE_CREDENTIALS_FILE, scopes=GOOGLE_SHEETS_SCOPES
        )
        client = gspread.authorize(creds)
        sheet = client.open_by_key(sid).sheet1
        service = build("sheets", "v4", credentials=creds)

        _svetofor_cache.update({
            "sheet": sheet,
            "service": service,
            "spreadsheet_id": sid,
        })

def _load_svetofor_data() -> None:
    """
    Загружает meta с includeGridData и сохраняет строки + заголовки.
    Вызывается единожды за генерацию отчёта.
    """
    if _svetofor_cache["rows"] is None:
        svc = _svetofor_cache["service"]
        sid = _svetofor_cache["spreadsheet_id"]
        meta = svc.spreadsheets().get(
            spreadsheetId=sid, includeGridData=True
        ).execute()

        # найдём нужный лист по sheetId
        props = _svetofor_cache["sheet"].id
        sheet_meta = next(
            s for s in meta["sheets"]
            if s["properties"]["sheetId"] == props
        )
        rows = sheet_meta["data"][0].get("rowData", [])
        # первая строка — заголовки
        header_cells = rows[0].get("values", [])
        headers = [
            c.get("formattedValue", "").strip()
            for c in header_cells
        ]

        _svetofor_cache["rows"] = rows
        _svetofor_cache["headers"] = headers

async def get_user_row_from_svetofor(user_id: int) -> Optional[int]:
    """
    Ищет user_id (в коло́нке B) и возвращает номер строки (1-based),
    или None, если не найден.
    """
    try:
        _init_svetofor()
        _load_svetofor_data()
        rows = _svetofor_cache["rows"]
        target = str(user_id)
        for idx, row in enumerate(rows, start=1):
            vals = row.get("values", [])
            # столбец B → индекс 1
            if len(vals) > 1 and vals[1].get("formattedValue", "").strip() == target:
                return idx
    except Exception as e:
        logger.error("[5.0] get_user_row_from_svetofor: %s", e, exc_info=True)
    return None

async def get_game_column_from_svetofor(game_name: str) -> Optional[int]:
    """
    Ищет заголовок game_name в первой строке (без учёта регистра),
    возвращает номер столбца (1-based) или None.
    """
    try:
        _init_svetofor()
        _load_svetofor_data()
        norm = game_name.strip().lower()
        for idx, title in enumerate(_svetofor_cache["headers"], start=1):
            if title.lower() == norm:
                return idx
        logger.warning("[5.0] get_game_column: заголовок %r не найден", game_name)
    except Exception as e:
        logger.error("[5.0] get_game_column_from_svetofor: %s", e, exc_info=True)
    return None

def _rgb_to_status(r: float, g: float, b: float) -> str:
    """
    Преобразует backgroundColor из 0.0–1.0 в:
      green  if (g>0.5 and r<0.5)
      yellow if (r>0.5 and g>0.5)
      red    if (r>0.5 and g<0.5)
      ""     иначе
    """
    if g > 0.5 and r < 0.5:
        return "green"
    if r > 0.5 and g > 0.5:
        return "yellow"
    if r > 0.5 and g < 0.5:
        return "red"
    return ""

async def get_user_status_from_svetofor(user_id: int, game_name: str) -> str:
    """
    По user_id и game_name возвращает цвет ячейки:
    'green' | 'yellow' | 'red' | ''.
    """
    try:
        row = await get_user_row_from_svetofor(user_id)
        col = await get_game_column_from_svetofor(game_name)
        if not row or not col:
            return ""
        # берём из кешированных rows
        cell = _svetofor_cache["rows"][row - 1] \
                    .get("values", [])[col - 1]
        bg = cell.get("effectiveFormat", {}) \
                 .get("backgroundColor", {})
        return _rgb_to_status(
            bg.get("red",   0.0),
            bg.get("green", 0.0),
            bg.get("blue",  0.0)
        )
    except Exception as e:
        logger.error("[5.0] get_user_status_from_svetofor: %s", e, exc_info=True)
        return ""


# ╔═══════════════════════════════════════════════════════════════════════════╗
# ║                                                                           ║
# ║                       [6.0] Работа с AmoCRM                               ║
# ║                                                                           ║
# ╚═══════════════════════════════════════════════════════════════════════════╝
# Описание: Функции для получения и обновления данных в AmoCRM с расширенным логированием.
# version: 2.3

# ───────────────────────────────── ensure_valid_token ─────────────────────────
async def ensure_valid_token() -> bool:
    """Возвращает True, если access‑token действителен (или успешно обновлён)."""
    try:
        if not bot_data.tokens:
            bot_data.tokens = await load_json(TOKENS_FILE)
            if not bot_data.tokens:
                logger.error("[6.0] ensure_valid_token: файл токенов пуст %s", TOKENS_FILE)
                return False

        expires_at = bot_data.tokens.get("expires_at", 0)
        if datetime.now().timestamp() >= expires_at - 300:
            logger.info("[6.0] ensure_valid_token: token истекает, обновляем …")
            return await refresh_amocrm_token()

        logger.debug("[6.0] ensure_valid_token: token ok до %s",
                     datetime.fromtimestamp(expires_at))
        return True
    except Exception as e:
        logger.exception("[6.0] ensure_valid_token: критическая ошибка %s", e)
        return False


# ─────────────────────────────── refresh_amocrm_token ────────────────────────
async def refresh_amocrm_token() -> bool:
    """Обновляет refresh‑токен и сохраняет на диск."""
    try:
        cfg = bot_data.config or {}
        required = ("client_id", "client_secret", "redirect_uri", "domain")
        if any(k not in cfg for k in required):
            logger.error("[6.0] refresh_amocrm_token: неполный конфиг AmoCRM %s", cfg)
            return False

        async with aiohttp.ClientSession() as s:
            payload = {
                "client_id":     cfg["client_id"],
                "client_secret": cfg["client_secret"],
                "grant_type":    "refresh_token",
                "refresh_token": bot_data.tokens.get("refresh_token", ""),
                "redirect_uri":  cfg["redirect_uri"],
            }
            async with s.post(f"https://{cfg['domain']}/oauth2/access_token",
                              json=payload) as r:
                if r.status != 200:
                    logger.error("[6.0] refresh_amocrm_token: HTTP %d – %s",
                                 r.status, await r.text())
                    return False
                data = await r.json()
                data["expires_at"] = (
                    datetime.now() + timedelta(seconds=data.get("expires_in", 86400))
                ).timestamp()
                bot_data.tokens.update(data)
                await save_json(TOKENS_FILE, bot_data.tokens)
                logger.info("[6.0] refresh_amocrm_token: token обновлён")
                return True
    except Exception as e:
        logger.exception("[6.0] refresh_amocrm_token: сбой %s", e)
        return False


# ──────────────────────────────── get_pipeline_stages ────────────────────────
async def get_pipeline_stages() -> Dict[str, str]:
    """ID‑→‑Название статусов всех воронок."""
    try:
        if not await ensure_valid_token():
            return {}

        async with aiohttp.ClientSession() as s:
            head = {"Authorization": f"{bot_data.tokens['token_type']} {bot_data.tokens['access_token']}"}
            async with s.get(f"https://{bot_data.config['domain']}/api/v4/leads/pipelines",
                             headers=head) as r:
                if r.status != 200:
                    logger.error("[6.0] get_pipeline_stages: HTTP %d", r.status)
                    return {}
                js = await r.json()
                stages = {
                    str(st["id"]): st["name"]
                    for pl in js["_embedded"]["pipelines"]
                    for st in pl["_embedded"]["statuses"]
                }
                logger.debug("[6.0] get_pipeline_stages: %d статусов", len(stages))
                return stages
    except Exception as e:
        logger.exception("[6.0] get_pipeline_stages: ошибка %s", e)
        return {}


# ───────────────────────────────── get_custom_fields ─────────────────────────
async def get_custom_fields() -> Dict[str, str]:
    """ID‑→‑Название всех кастомных полей сделок."""
    try:
        if not await ensure_valid_token():
            return {}

        async with aiohttp.ClientSession() as s:
            head = {"Authorization": f"{bot_data.tokens['token_type']} {bot_data.tokens['access_token']}"}
            async with s.get(f"https://{bot_data.config['domain']}/api/v4/leads/custom_fields",
                             headers=head) as r:
                if r.status != 200:
                    logger.error("[6.0] get_custom_fields: HTTP %d", r.status)
                    return {}
                js = await r.json()
                fields = {str(f["id"]): f["name"] for f in js["_embedded"]["custom_fields"]}
                logger.debug("[6.0] get_custom_fields: %d полей", len(fields))
                return fields
    except Exception as e:
        logger.exception("[6.0] get_custom_fields: ошибка %s", e)
        return {}


# ─────────────────────────────── fetch_amocrm_deals ─────────────────────────
async def fetch_amocrm_deals(spreadsheet_id: str) -> List[Dict]:
    """Ходит в AmoCRM, возвращает обработанные сделки."""
    try:
        if not bot_data.config or not await ensure_valid_token():
            return []

        custom_fields, stages = await asyncio.gather(
            get_custom_fields(), get_pipeline_stages()
        )
        if not custom_fields or not stages:
            return []

        # 👉 сохраняем ID поля «Предоплата»
        global PREPAYMENT_FIELD_ID
        PREPAYMENT_FIELD_ID = next(
            (fid for fid, name in custom_fields.items() if "предоплат" in name.lower()),
            None
        )

        deals: List[Dict] = []
        page, limit = 1, 250
        updated_from = int((datetime.now() - timedelta(days=DATE_FILTER_DAYS)).timestamp())
        pipeline_id = bot_data.config.get("pipeline_id")  # может быть None

        async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=20)) as s:
            head = {"Authorization": f"{bot_data.tokens['token_type']} {bot_data.tokens['access_token']}"}

            while True:
                params: Dict[str, Union[str, int]] = {
                    "with": "contacts,tags",
                    "limit": limit,
                    "page": page,
                    "filter[updated_at][from]": updated_from,
                }
                # не отправляем None → иначе TypeError inside yarl
                if pipeline_id:
                    params["filter[pipeline_id]"] = pipeline_id

                # корректное перечисление статусов (как в рабочей 12.90)
                for i, sid in enumerate(ALLOWED_STATUS_IDS):
                    params[f"filter[statuses][{i}][pipeline_id][0][statuses][0]"] = sid

                async with s.get(f"https://{bot_data.config['domain']}/api/v4/leads",
                                 headers=head, params=params) as r:
                    logger.debug("[6.0] fetch_amocrm_deals: p.%d http=%d", page, r.status)

                    if r.status == 204:
                        break
                    if r.status == 401 and await refresh_amocrm_token():
                        head["Authorization"] = (
                            f"{bot_data.tokens['token_type']} {bot_data.tokens['access_token']}"
                        )
                        continue
                    if r.status != 200:
                        logger.error("[6.0] fetch_amocrm_deals: HTTP %d – %s",
                                     r.status, await r.text())
                        return []

                    js = await r.json()
                    leads = js.get("_embedded", {}).get("leads", [])
                    if not leads:
                        break

                    for raw in leads:
                        if str(raw.get("status_id")) in ALLOWED_STATUS_IDS:
                            processed = await process_deal(raw, stages, custom_fields, spreadsheet_id)
                            if processed:
                                deals.append(processed)

                    page += 1
                    await asyncio.sleep(1)  # soft‑limit

        deals.sort(key=lambda d: d["event_datetime"])
        logger.info("[6.0] fetch_amocrm_deals: %d сделок", len(deals))
        return deals

    except Exception as e:
        logger.exception("[6.0] fetch_amocrm_deals: критическая ошибка %s", e)
        return []


# ───────────────────────────────── get_amocrm_deals ─────────────────────────
async def get_amocrm_deals(spreadsheet_id: str, refresh: bool = False) -> List[Dict]:
    """Возвращает сделки из кэша либо обновляет кэш при необходимости."""
    try:
        cache_key = f"deals_{spreadsheet_id}"
        cache_entry = bot_data.deals_cache.get(cache_key)
        if cache_entry and not refresh:
            age = datetime.now() - cache_entry["timestamp"]
            if age < CACHE_LIFETIME:
                logger.debug("[6.0] deals‑cache HIT | %s | age %.1fs", spreadsheet_id, age.total_seconds())
                return cache_entry["deals"]

        deals = await fetch_amocrm_deals(spreadsheet_id)
        bot_data.deals_cache[cache_key] = {"deals": deals, "timestamp": datetime.now()}
        logger.debug("[6.0] deals‑cache обновлён | %s | %d сделок", spreadsheet_id, len(deals))
        return deals
    except Exception as e:
        logger.exception("[6.0] get_amocrm_deals: ошибка %s", e)
        return []


# ─────────────────────────────── update_amocrm_tags ─────────────────────────
async def update_amocrm_tags(deal_id: int, tags: List[str]) -> bool:
    """Патчит теги сделки.  True → успешно."""
    try:
        if not await ensure_valid_token():
            return False

        async with aiohttp.ClientSession() as s:
            head = {"Authorization": f"{bot_data.tokens['token_type']} {bot_data.tokens['access_token']}"}
            payload = {"_embedded": {"tags": [{"name": t} for t in tags]}}

            async with s.patch(f"https://{bot_data.config['domain']}/api/v4/leads/{deal_id}",
                               headers=head, json=payload) as r:
                if r.status == 429:
                    await asyncio.sleep(1)
                    async with s.patch(f"https://{bot_data.config['domain']}/api/v4/leads/{deal_id}",
                                       headers=head, json=payload) as r2:
                        r = r2  # повторный ответ

                if r.status != 200:
                    logger.error("[6.0] update_amocrm_tags: HTTP %d – %s", r.status, await r.text())
                    return False

                logger.info("[6.0] update_amocrm_tags: ok deal=%d %s", deal_id, tags)
                return True
    except Exception as e:
        logger.exception("[6.0] update_amocrm_tags: ошибка %s", e)
        return False

# version: 2.3
# История изменений:
# - 2.0 (12.05.2025): пагинация, расширенный лог.
# - 2.1 (13.05.2025): детализация ошибок.
# - 2.2 (14.05.2025): фиксы JSON‑decode и rate‑limit.
# - 2.3 (15.05.2025): исключён pipeline_id=None, статусы формируются корректно —
#                    устранён TypeError «Invalid variable type» при запросе.

# ╔═══════════════════════════════════════════════════════════════════════════╗
# ║                                                                           ║
# ║                   [7.0] Обработка данных AmoCRM                           ║
# ║                                                                           ║
# ╚═══════════════════════════════════════════════════════════════════════════╝
# Описание: превращает «сырую» сделку из AmoCRM в единый dict для бота.
#           • Поддерживает множественные значения для поля «Доп. услуги»
#           • Понимает Unix-таймстамп (сек/мс) и текстовые форматы даты/времени
#           • Всегда возвращает отдельное поле event_time (строка «HH:MM»)
#           • Логирует только начало и результат обработки
# version: 2.8 (13.05.2025) — сокращено логирование, добавлено отображение комментариев

def _parse_event_datetime(raw_date: Any, raw_time: Any) -> Optional[datetime]:
    """
    Универсальный парсер даты + времени из AmoCRM.
    """
    try:
        ts = float(raw_date)
        if ts > 1e12:
            ts /= 1000
        return MSK_TZ.localize(datetime.fromtimestamp(int(ts)))
    except (TypeError, ValueError):
        pass

    date_str = str(raw_date or "").strip()
    time_str = str(raw_time or "").strip()
    if time_str.lower() == "не указано":
        time_str = ""
    candidate = f"{date_str} {time_str}".strip()

    for fmt in (
        "%Y-%m-%d %H:%M", "%d.%m.%Y %H:%M",
        "%d/%m/%Y %H:%M", "%Y.%m.%d %H:%M",
        "%Y-%m-%d",      "%d.%m.%Y",
        "%d/%m/%Y",      "%Y.%m.%d"
    ):
        try:
            dt = datetime.strptime(candidate, fmt)
            if " %H:%M" not in fmt:
                dt = dt.replace(hour=0, minute=0)
            return MSK_TZ.localize(dt)
        except ValueError:
            continue

    return None


async def process_deal(
    deal: Dict,
    stages: Dict[str, str],
    custom_fields: Dict[str, str],
    spreadsheet_id: str,
) -> Optional[Dict]:
    """
    Преобразует «сырую» сделку AmoCRM в унифицированный dict.
    """
    deal_id = deal.get("id")
    if not deal_id:
        logger.warning("[7.0] process_deal: нет id сделки")
        return None

    logger.info("[7.0] process_deal START deal_id=%s", deal_id)

    try:
        # Собираем custom_fields_values
        cf_raw = deal.get("custom_fields_values") or []
        cf: Dict[str, List[Any]] = {
            str(f.get("field_id")): [v["value"] for v in f.get("values", []) if v.get("value") is not None]
            for f in cf_raw
        }

        # Парсим дату и время
        raw_date = cf.get(AMOCRM_FIELDS["event_date"], [None])[0]
        raw_time = cf.get(AMOCRM_FIELDS["event_time"], [""])[0]
        event_dt = _parse_event_datetime(raw_date, raw_time)
        if not event_dt:
            logger.error("[7.0] process_deal: не удалось распарсить дату deal_id=%s", deal_id)
            return None
        event_time = (str(raw_time).strip()
                      if raw_time and str(raw_time).strip().lower() != "не указано"
                      else event_dt.strftime("%H:%M"))

        # Финансы
        def to_int(val, default=0):
            try:
                return int(float(str(val).replace(",", ".")))
            except (TypeError, ValueError):
                return default

        total_budget = deal.get("price", 0)
        prepayment   = to_int(cf.get(AMOCRM_FIELDS["prepayment"], [0])[0])
        to_calculate = total_budget - prepayment

        # Ведущие
        leads_raw = cf.get(AMOCRM_FIELDS["team_leads"], [])
        team_leads = [
            {"id": lid, "name": get_lead_name(lid)}
            for lid in map(str, leads_raw) if lid.strip()
        ]

        # Доп. услуги
        pinata_list    = cf.get(AMOCRM_FIELDS["extra_services"], [])  # «Пиньята в подарок»
        other_services = cf.get("413875", [])  # «Дополнительно»
        all_services   = pinata_list + other_services
        extra_services = ", ".join(map(str, all_services)) if all_services else ""

        # Пакет услуг
        package_list = cf.get(AMOCRM_FIELDS["package"], [""])
        package = str(package_list[0]) if package_list else ""

        # Прочие поля
        game_name    = cf.get(AMOCRM_FIELDS["game_name"], [""])[0]
        players      = cf.get(AMOCRM_FIELDS["players"], [""])[0]
        age          = cf.get(AMOCRM_FIELDS["age"], [""])[0]
        comment      = cf.get(AMOCRM_FIELDS["comment"], [""])[0] or ""
        photographer = cf.get(AMOCRM_FIELDS["photographer"], [""])[0] or ""

        processed = {
            "id":                 deal_id,
            "name":               deal.get("name", f"Сделка {deal_id}"),
            "game_name":          game_name,
            "status_id":          str(deal.get("status_id", "")),
            "status":             stages.get(str(deal.get("status_id", "")), "Неизвестно"),
            "event_datetime":     event_dt,
            "event_datetime_str": f"{event_dt.strftime('%d.%m.%Y')}, {event_time}",
            "event_time":         event_time,
            "players":            players,
            "players_count":      parse_players_count(players),
            "age":                age,
            "package":            package,
            "extra_services":     extra_services,
            "comment":            comment,
            "total_budget":       total_budget,
            "prepayment":         prepayment,
            "to_calculate":       to_calculate,
            "team_leads":         team_leads,
            "photographer":       photographer,
        }

        logger.info("[7.0] process_deal DONE deal_id=%s", deal_id)
        return processed

    except Exception as e:
        logger.exception("[7.0] process_deal: ошибка deal_id=%s: %s", deal_id, e)
        return None


# ╔═══════════════════════════════════════════════════════════════════════════╗
# ║                                                                           ║
# ║                    [8.0] Пользовательские данные                          ║
# ║                                                                           ║
# ╚═══════════════════════════════════════════════════════════════════════════╝
# Описание: Функции для работы с информацией о пользователях из SQLite (checklists.db).
# version: 1.3

def get_user_info(user_id: int) -> Optional[Dict]:
    """Получает информацию о пользователе из SQLite.

    Args:
        user_id: ID пользователя.

    Returns:
        Optional[Dict]: {
            first_name: str,
            last_name_initial: str,
            role: str,
            status: str,
            games_last_30_days: int
        } или None, если не найден.
    """
    try:
        import sqlite3

        db_path = os.path.join(BASE_DIR, "checklists.db")
        conn = sqlite3.connect(db_path)
        cursor = conn.cursor()
        cursor.execute(
            "SELECT first_name, last_name, role FROM users WHERE user_id = ?",
            (user_id,)
        )
        row = cursor.fetchone()
        conn.close()

        if not row:
            logger.warning("[8.0] get_user_info: Пользователь %d не найден в базе %s", user_id, db_path)
            return None

        first_name, last_name, role = row
        last_initial = last_name[0] if last_name else ""
        user_data = {
            "first_name": first_name or "",
            "last_name_initial": last_initial,
            "role": role or "",
            "status": "green",
            "games_last_30_days": 0
        }
        logger.debug("[8.0] get_user_info: Загружен '%s' для пользователя %d", role, user_id)
        return user_data

    except Exception as e:
        logger.error("[8.0] get_user_info: Ошибка чтения из базы для %d: %s", user_id, e, exc_info=True)
        return None

def get_lead_name(lead_id: str) -> str:
    """Получает имя ведущего по ID.

    Args:
        lead_id: ID ведущего.

    Returns:
        str: Имя ведущего.
    """
    try:
        logger.debug("[8.0] get_lead_name: Запрошено имя для lead_id %s", lead_id)
        return "Unknown Lead"
    except Exception as e:
        logger.error("[8.0] get_lead_name: Ошибка для lead_id %s: %s", lead_id, e, exc_info=True)
        return "Unknown Lead"

# version: 1.3
# История изменений:
# - 1.0: Базовые заглушки.
# - 1.1 (11.05.2025): Добавлено логирование с разделом.
# - 1.2 (12.05.2025): Реально возвращали роль «руководитель» для LEADER_ID.
# - 1.3 (12.05.2025): Подключение к базе checklists.db для получения first_name, last_name и role.

# ╔═══════════════════════════════════════════════════════════════════════════╗
# ║                                                                           ║
# ║                        [9.0] Маппинг данных                               ║
# ║                                                                           ║
# ╚═══════════════════════════════════════════════════════════════════════════╝
# Описание: Генерация маппинга для pipeline и статусов.
# version: 1.1

async def generate_name_mapping() -> None:
    """Генерирует маппинг pipeline и статусов."""
    try:
        bot_data.pipeline_mapping = {
            "pipeline_id": {
                "name": "Main Pipeline",
                "stages": {
                    "142": "New",
                    "18913933": "In Progress",
                    "18913930": "Successful"
                }
            }
        }
        logger.info("[9.0] generate_name_mapping: Маппинг pipeline сгенерирован")
    except Exception as e:
        logger.error("[9.0] generate_name_mapping: Ошибка генерации маппинга: %s", e, exc_info=True)
        
# ╔═══════════════════════════════════════════════════════════════════════════╗
# ║                  [10.0] Обработка Telegram-сообщений                      ║
# ╚═══════════════════════════════════════════════════════════════════════════╝
# Описание: стартовое меню, «Новые / Распределённые игры» и запуск опроса.
# version: 1.9 (07.06.2025)  — фикс ограничения 100 симв. на варианты опроса

from aiogram.types import ReplyKeyboardRemove
router = Router()

# ─────────────────────────── /start ────────────────────────────
@router.message(CommandStart())
async def start_handler(message: types.Message) -> None:
    """/start — приветствие и показ главного меню."""
    user_id = message.from_user.id
    try:
        first_name = message.from_user.first_name or "Пользователь"
        kb = await get_main_menu(user_id)
        txt = (
            f"🎉 Привет, {first_name}! Я MasterBot {VERSION} 🤖\n"
            f"Твой ID: {user_id}\n"
        )
        txt += (
            "К сожалению, у вас нет доступных действий."
            if not kb else "Я помогу управлять распределением ведущих на квесты."
        )
        await message.answer(txt, reply_markup=kb or ReplyKeyboardRemove())
        logger.info("[10.0] start_handler: user=%d name=%s", user_id, first_name)
    except Exception as e:
        logger.error("[10.0] start_handler: %s", e, exc_info=True)
        await message.answer(
            "⚠️ Произошла ошибка. Попробуйте позже.",
            reply_markup=ReplyKeyboardRemove()
        )

# ──────────────── 📅 Новые игры ────────────────
@router.message(lambda m: m.text and m.text.strip() in {"📅 Новые игры", "\U0001F4C5 Новые игры"})
async def new_games_handler(message: types.Message) -> None:
    user_id = message.from_user.id
    ui = get_user_info(user_id)

    if not ui or ui["role"] not in ACCESS["games"]:
        await message.answer("⛔ Нет доступа.", reply_markup=await get_main_menu(user_id))
        return

    await show_games(
        message=message,
        user_id=user_id,
        status_ids=NEW_GAMES_STATUS_IDS,
        title="📅 Новые игры:",
        only_unassigned=True
    )
    logger.info("[10.0] new_games_handler: список игр отправлен %d", user_id)

# ──────────────── ✅ Распределённые игры ────────────────
@router.message(lambda m: m.text and m.text.strip() == "✅ Распределённые игры")
async def assigned_games_handler(message: types.Message) -> None:
    user_id = message.from_user.id
    ui = get_user_info(user_id)

    if not ui or ui["role"] not in ACCESS["games"]:
        await message.answer("⛔ Нет доступа.", reply_markup=await get_main_menu(user_id))
        return

    await show_games(
        message=message,
        user_id=user_id,
        status_ids=[SUCCESSFUL_STATUS_ID],
        title="✅ Распределённые игры:"
    )

# ──────────────── 📋 Создать опрос ────────────────
@router.message(lambda m: m.text and m.text.strip() == "📋 Создать опрос")
async def create_poll_handler(message: types.Message) -> None:
    """Создаёт опросы по ближайшим 14 дням и формирует дашборд-отчёт."""
    user_id = message.from_user.id

    # ── проверки доступа ───────────────────────────────────────────────
    if not await has_access(user_id, "poll"):
        await message.answer("⛔ Нет доступа.", reply_markup=await get_main_menu(user_id))
        return
    if bot_data.coordination_cycle_active:
        await message.answer("⚠️ Уже есть активный опрос.")
        return
    if not bot_data.admin_chat_id or not await is_bot_admin(bot_data.admin_chat_id):
        await message.answer("⚠️ Чат ведущих не настроен или бот не админ.")
        return
    sid = bot_data.config.get("svetofor_spread_id")
    if not sid:
        await message.answer("⚠️ Не указан ID таблицы «Светофор».")
        return
    # ──────────────────────────────────────────────────────────────────

    deals = await get_amocrm_deals(sid)
    now, window_end = datetime.now(tz=MSK_TZ), datetime.now(tz=MSK_TZ) + timedelta(days=14)
    poll_deals = [
        d for d in deals
        if d["status_id"] in NEW_GAMES_STATUS_IDS
        and now <= d["event_datetime"] <= window_end
        and not d["team_leads"]
    ]
    if not poll_deals:
        await message.answer("😔 Нет подходящих игр для опроса.",
                             reply_markup=await get_main_menu(user_id))
        return

    # ── подготовка опросов ─────────────────────────────────────────────
    poll_deals.sort(key=lambda x: x["event_datetime"])
    bot_data.current_poll_deals       = poll_deals
    bot_data.current_poll_leader      = user_id
    bot_data.responses.clear()
    bot_data.coordination_cycle_active = True
    # -------------------------------------------------------------------

    chunks      = [poll_deals[i:i + 8] for i in range(0, len(poll_deals), 8)]
    urgent      = any(d["event_datetime"] <= now + timedelta(days=3) for d in poll_deals)
    base_header = "🚨 Срочные игры!" if urgent else "📊 Новые игры"

    for idx, chunk in enumerate(chunks, 1):
        header  = f"{base_header} (Часть {idx})" if len(chunks) > 1 else base_header
        options, indices = [], {}

        for i, d in enumerate(chunk):
            date = d["event_datetime"].strftime("%d.%m")

            # ── формируем вариант опроса ≤ 100 симв. ─────────────────
            text = f"🎉 {d['name']} – {date}"
            if d["package"]:
                text = f"{text} – {d['package']}"

            if d["extra_services"]:
                rest = 100 - len(text) - 1          # +1 на пробел перед услугами
                if rest > 0:
                    extra = d["extra_services"]
                    if len(extra) > rest:
                        extra = extra[:rest - 1].rstrip(", ") + "…"
                    text = f"{text} {extra}"

            if len(text) > 100:                     # страховка
                text = text[:97].rstrip(", ") + "…"
            # ───────────────────────────────────────────────────────────

            options.append(text)
            indices[i] = d["id"]

        options += ["🚫 Не смогу работать", "🛡️ Могу администратором"]

        poll_msg = await bot.send_poll(
            bot_data.admin_chat_id,
            header,
            options,
            is_anonymous=False,
            allows_multiple_answers=True
        )
        bot_data.responses[poll_msg.poll.id] = {
            "deals": {d["id"]: [] for d in chunk},
            "admin_available": [],
            "not_available": [],
            "deal_indices": indices
        }

    # ── формируем личный дашборд ───────────────────────────────────────
    report_text = await generate_poll_report()

    dash_msg = await bot.send_message(
        user_id,
        report_text,
        reply_markup=bot_data.distribution_keyboard,
        parse_mode="Markdown"
    )
    bot_data.personal_report_message_id = dash_msg.message_id

    # отдельное сообщение с кнопками действий
    await bot.send_message(
        user_id,
        "ℹ️ Действия с опросом:",
        reply_markup=get_distribution_keyboard()
    )

    await report_unknown_names()

    # ── очистка данных через 24 ч ───────────────────────────────────────
    scheduler.add_job(
        clear_poll_data,
        "date",
        run_date=now + POLL_DURATION,
        args=[user_id],
        id=f"clear_poll_{user_id}",
        replace_existing=True
    )

    await message.answer("✅ Опросы отправлены.", reply_markup=await get_main_menu(user_id))
    logger.info("[10.0] create_poll_handler: polls for %d deals", len(poll_deals))



# ╔═══════════════════════════════════════════════════════════════════════════╗
# ║                                                                           ║
# ║                      [11.0] Callback-обработчики                          ║
# ║                                                                           ║
# ╚═══════════════════════════════════════════════════════════════════════════╝
# Обработка callback c.data="game_details_<id>" — показывает полные детали,
# включая «Пакет услуг» и «Доп. услуги».
# Добавлена кнопка возврата к списку игр.
@router.callback_query(lambda c: c.data.startswith("game_details_"))
async def game_details_handler(callback: types.CallbackQuery) -> None:
    user_id = callback.from_user.id
    deal_id = int(callback.data.split("_")[-1])
    try:
        # поиск сделки в кэше пользователя или в текущем опросе
        deal = next(
            (d for d in bot_data.games_by_user.get(user_id, []) if d["id"] == deal_id),
            next((d for d in bot_data.current_poll_deals if d["id"] == deal_id), None)
        )
        if not deal:
            await callback.answer("⚠️ Игра не найдена.", show_alert=True)
            return

        # подготовка текста деталей
        date_part    = (deal.get("event_datetime_str") or "—").split(",")[0]
        time_part    = deal.get("event_time", "—")
        quest        = deal.get("game_name", "—")
        package      = deal.get("package", "—")
        status       = deal.get("status", "—")
        players      = deal.get("players", "—")
        age          = deal.get("age", "—")
        extra        = deal.get("extra_services", "—")
        comment      = deal.get("comment", "—")
        prepay       = deal.get("prepayment", 0)
        leads        = ", ".join(l.get("name", "") for l in deal.get("team_leads", [])) or "—"
        photographer = deal.get("photographer", "—")
        total_budget = deal.get("total_budget", 0)
        to_calc      = deal.get("to_calculate", 0)

        text = "\n".join([
            f"🎮 *Игра*: {quest}",
            f"🎁 *Пакет услуг*: {package}",
            f"🔖 *Статус*: {status}",
            f"📅 *Дата*: {date_part}",
            f"🕒 *Время*: {time_part}",
            f"👥 *Игроки*: {players}",
            f"⚠️ *Возраст*: {age}",
            f"➕ *Доп. услуги*: {extra}",
            f"💬 *Комментарий*: {comment}",
            f"💸 *Предоплата*: {prepay} ₽",
            f"🧑‍🤝‍🧑 *Ведущие*: {leads}",
            f"📷 *Фотограф*: {photographer}",
            f"💰 *Бюджет*: {total_budget} ₽",
            f"🧮 *К расчёту*: {to_calc} ₽",
        ])

        # кнопка возврата
        kb = InlineKeyboardBuilder()
        kb.button(text="⬅️ Назад к списку", callback_data="back_to_games_list")
        kb.adjust(1)

        await callback.message.answer(text, reply_markup=kb.as_markup(), parse_mode="Markdown")
        await callback.answer()

    except Exception as e:
        await callback.answer("⚠️ Ошибка при загрузке деталей.", show_alert=True)


@router.callback_query(lambda c: c.data == "back_to_games_list")
async def back_to_games_list_handler(callback: types.CallbackQuery) -> None:
    """Возвращает пользователя к списку игр."""
    user_id = callback.from_user.id
    try:
        games = bot_data.games_by_user.get(user_id)
        if not games:
            await callback.answer("😔 Список игр недоступен.", show_alert=True)
            return

        # восстановление списка
        kb = InlineKeyboardBuilder()
        for d in games:
            btn_text = f"🎉 {d['name']} {d['event_time']}"
            kb.button(text=btn_text, callback_data=f"game_details_{d['id']}")
        kb.adjust(1)

        await callback.message.answer("📋 Список игр:\nВыберите игру:", reply_markup=kb.as_markup())
        await callback.answer()

    except Exception:
        await callback.answer("⚠️ Не удалось вернуться к списку.", show_alert=True)

# ╔═══════════════════════════════════════════════════════════════════════════╗
# ║                  [11.2] report_back_handler (⬅️ Назад)                    ║
# ╚═══════════════════════════════════════════════════════════════════════════╝
# Показывает исходный список игр из отчёта, когда пользователь нажимает «Назад»
# version: 1.0 (30.05.2025)

@router.callback_query(lambda c: c.data == "report_back")
async def report_back_handler(callback: types.CallbackQuery) -> None:
    """Возврат из подробного отчёта по игре к списку игр-кнопок."""
    try:
        await callback.message.delete()                 # убираем детальный отчёт
        # перерисовываем «главную» клавиатуру отчёта
        await bot.edit_message_text(
            await generate_poll_report(),
            chat_id=callback.from_user.id,
            message_id=bot_data.personal_report_message_id,
            reply_markup=bot_data.distribution_keyboard,
            parse_mode="Markdown"
        )
        await callback.answer()
    except Exception:
        # если сообщение уже удалено — просто игнорируем
        await callback.answer()

# ╔═══════════════════════════════════════════════════════════════════════════╗
# ║                                                                           ║
# ║                          [12.0] Клавиатуры                                ║
# ║                                                                           ║
# ╚═══════════════════════════════════════════════════════════════════════════╝
# Описание: Генерация reply‑ и inline‑клавиатур для взаимодействия с ботом.
# version: 1.4

from typing import List, Optional
from aiogram.types import ReplyKeyboardMarkup, KeyboardButton
from aiogram.utils.keyboard import ReplyKeyboardBuilder   # aiogram 3.x builder

async def get_main_menu(user_id: int) -> Optional[ReplyKeyboardMarkup]:
    """Создаёт главное меню в зависимости от роли пользователя."""
    try:
        user_info = get_user_info(user_id) or {}
        role = user_info.get("role", "")

        # — формируем список кнопок —
        btns: List[KeyboardButton] = []
        if role in ACCESS["games"]:
            btns.extend([
                KeyboardButton(text="\U0001F4C5 Новые игры"),
                KeyboardButton(text="\U00002705 Распределённые игры")
            ])
        if role in ACCESS["poll"]:
            btns.append(KeyboardButton(text="\U0001F4CB Создать опрос"))

        if not btns:
            logger.warning("[12.0] get_main_menu: Нет доступных кнопок для %d, role=%s",
                           user_id, role)
            return None

        # — собираем клавиатуру через builder —
        builder = ReplyKeyboardBuilder()
        builder.add(*btns)
        builder.adjust(2)                         # 2 кнопки в строке
        markup = builder.as_markup(resize_keyboard=True)
        logger.debug("[12.0] get_main_menu: Сгенерировано меню для %d (%s), %d кнопок",
                     user_id, role, len(btns))
        return markup
    except Exception as exc:
        logger.error("[12.0] get_main_menu: Ошибка для %d: %s", user_id, exc, exc_info=True)
        return None

# ─────────────────────────────────────────────────────────────────────────────
# История изменений:
# - 1.0 (??.05.2025): Базовая реализация.
# - 1.1 (11.05.2025): Логи + проверка пустых кнопок.
# - 1.2 (14.05.2025): Исправлена валидация ReplyKeyboardMarkup.
# - 1.3 (15.05.2025): Переведено на ReplyKeyboardBuilder.
# - 1.4 (15.05.2025): Финальная правка — убрана старая строка с пустым ReplyKeyboardMarkup.
# ╔═══════════════════════════════════════════════════════════════════════════╗
# ║                     [12.1] Клавиатура распределения                       ║
# ╚═══════════════════════════════════════════════════════════════════════════╝
# Описание: единая клавиатура к личному отчёту руководителя
#           («👌 Утвердить», «💾 Сохранить», «🔧 Изменить вручную»)
#           Вызывается из create_poll_handler через get_distribution_keyboard()
# version: 1.0 (30.05.2025)

def get_distribution_keyboard() -> InlineKeyboardMarkup:
    """Возвращает инлайн-клавиатуру для действий над распределением."""
    kb = InlineKeyboardBuilder()
    kb.button(text="👌 Утвердить распределение",
              callback_data="distribute_leaders")
    kb.button(text="💾 Сохранить в AmoCRM",
              callback_data="save_distribution")
    kb.button(text="🔧 Изменить состав вручную",
              callback_data="manual_edit")
    kb.adjust(1)          # каждая кнопка в новой строке
    return kb.as_markup()


# ████████████████████████████████████████████████████████████████████████████
# █                                                                         █
# █                       [13.0] generate_poll_report                        █
# █                                                                         █
# ████████████████████████████████████████████████████████████████████████████
# Описание: строит личный «дашборд»-отчёт руководителя.
#           Для каждой игры создаётся кнопка-строка вида
#           ✅ Квест — DD.MM   или   ❌ Квест — DD.MM
#           Галочка ставится, если минимальный состав собран.
#           Клавиатура сохраняется в bot_data.distribution_keyboard.
# version: 6.1 (30.05.2025)

from aiogram.types import InlineKeyboardButton, InlineKeyboardMarkup

async def generate_poll_report() -> str:
    logger.debug("[13.0] generate_poll_report: start")

    # Если опрос не запущен или нет откликов — просто уведомляем
    if not bot_data.current_poll_deals or not bot_data.responses:
        return "⚠️ Нет активных опросов."

    keyboard: list[list[InlineKeyboardButton]] = []

    for deal in bot_data.current_poll_deals:
        deal_id   = deal["id"]
        name      = deal.get("game_name", "—")
        date_str  = deal["event_datetime"].strftime("%d.%m")
        pkg_lower = (deal.get("package") or "").strip().lower()

        # Требуемые роли по константе
        role_def    = GAME_ROLE_MAPPING.get(name, {"main_leaders": 1, "assistants": 0})
        need_main   = role_def["main_leaders"]
        need_assist = role_def["assistants"]
        need_admin  = 1 if pkg_lower in ("стандарт", "стандарт+", "премиум", "vip", "вип") else 0

        # Собираем всех, кто откликнулся на эту игру
        respondents: list[dict] = []
        for poll_data in bot_data.responses.values():
            respondents += poll_data["deals"].get(deal_id, [])

        # Считаем, сколько зеленых/желтых/админских откликов
        have_main = have_assist = have_admin = 0
        for u in respondents:
            status = await get_user_status_from_svetofor(u["user_id"], name)
            if status == "green":
                have_main += 1
                have_assist += 1  # зелёный годится и как помощник
            elif status == "yellow":
                have_assist += 1
            if u.get("is_admin_eligible"):
                have_admin += 1

        ready = (
            have_main   >= need_main and
            have_assist >= need_assist and
            have_admin  >= need_admin
        )
        icon = "✅" if ready else "❌"
        btn_text = f"{icon} {name} — {date_str}"

        keyboard.append([
            InlineKeyboardButton(text=btn_text, callback_data=f"show_deal_{deal_id}")
        ])

    bot_data.distribution_keyboard = InlineKeyboardMarkup(inline_keyboard=keyboard)
    return "📊 *Опрос создан. Выберите игру для просмотра и редактирования состава:*"


# ╔═══════════════════════════════════════════════════════════════════════════╗
# ║                 [13.0.1] show_deal_callback_handler                       ║
# ╚═══════════════════════════════════════════════════════════════════════════╝
# Описание: Показывает подробный отчёт по одной игре с кнопками замены
# version: 1.0 (28.05.2025)

@router.callback_query(lambda c: c.data.startswith("show_deal_"))
async def show_deal_callback_handler(callback: types.CallbackQuery) -> None:
    try:
        deal_id = int(callback.data.split("_")[-1])
        deal = next((d for d in bot_data.current_poll_deals if d["id"] == deal_id), None)
        if not deal:
            await callback.answer("⚠️ Игра не найдена.", show_alert=True)
            return

        game = deal["game_name"]
        game_l = game.lower()
        date = deal["event_datetime"].strftime("%d.%m.%Y")
        time = deal["event_time"]
        pkg = (deal.get("package") or "").strip()
        pkg_lower = pkg.lower()
        players = parse_players_count(deal.get("players", 0))
        pkg_emoji = {
            "компакт": "🎒", "стандарт": "📦", "стандарт+": "📦➕",
            "премиум": "💎", "вип": "👑", "vip": "👑"
        }.get(pkg_lower, "🎁")

        role_def = GAME_ROLE_MAPPING.get(game, {"main_leaders": 1, "assistants": 0})
        need_main = role_def["main_leaders"]
        need_assist = role_def["assistants"]
        need_admin = 1 if pkg_lower in ("стандарт", "стандарт+", "премиум", "vip", "вип") else 0

        respondents = []
        for data in bot_data.responses.values():
            respondents += data["deals"].get(deal_id, [])

        used_ids = set()
        kb = InlineKeyboardBuilder()
        lines = [
            f"🎮 *Игра:* {game}",
            f"📅 *Дата:* {date}",
            f"🕒 *Время:* {time}",
            f"📦 *Пакет:* {pkg_emoji} {pkg or '—'}",
            f"👥 *Игроки:* {players}",
        ]

        async def role_block(label: str, role_type: str, required: int):
            nonlocal kb
            result = []
            selected, alt = [], []
            for u in respondents:
                if u["user_id"] in used_ids:
                    continue
                status = await get_user_status_from_svetofor(u["user_id"], game)
                if role_type == "main" and status == "green":
                    (selected if len(selected) < required else alt).append((u, status))
                elif role_type == "assist" and status in ("green", "yellow"):
                    (selected if len(selected) < required else alt).append((u, status))
                elif role_type == "admin" and u.get("is_admin_eligible"):
                    (selected if len(selected) < required else alt).append((u, "🛡️"))

            icon = {"main": "🧭", "assist": "🛟", "admin": "🛡️"}[role_type]
            result.append(f"\n───── {icon} *{label.upper()}* ─────")
            result.append(f"✅ {len(selected)}/{required}")
            if not selected:
                result.append("– —")
            for u, st in selected:
                used_ids.add(u["user_id"])
                name = f"{u['first_name']} {u['last_name_initial']}"
                result.append(f"– {name} {st if st in ['🛡️'] else '🟢' if st == 'green' else '🟡'}")

            if alt:
                result.append("🔁 *Альтернатива:*")
                for u, st in alt:
                    name = f"{u['first_name']} {u['last_name_initial']}"
                    btn = InlineKeyboardButton(
                        text=f"{name} {st if st in ['🛡️'] else '🟢' if st == 'green' else '🟡'}",
                        callback_data=f"swap_{deal_id}_{role_type}_{u['user_id']}"
                    )
                    kb.row(btn)

            return result

        lines += await role_block("Ведущие", "main", need_main)
        lines += await role_block("Помощники", "assist", need_assist)
        lines += await role_block("Админ", "admin", need_admin)

        kb.row(
            InlineKeyboardButton(text="⬅️ Назад", callback_data="report_back")
        )
        await callback.message.answer("\n".join(lines), reply_markup=kb.as_markup(), parse_mode="Markdown")
        await callback.answer()

    except Exception as e:
        logger.error("[13.0.1] show_deal_callback_handler: %s", e, exc_info=True)
        await callback.answer("⚠️ Ошибка при отображении отчёта.", show_alert=True)
# ╔═══════════════════════════════════════════════════════════════════════════╗
# ║                      [13.0.1.1] assign_swap_handler                       ║
# ╚═══════════════════════════════════════════════════════════════════════════╝
# Описание: Меняет выбранного участника на текущей роли (ведущий, помощник, админ)
# version: 1.0 (28.05.2025)

@router.callback_query(lambda c: c.data.startswith("swap_"))
async def assign_swap_handler(callback: types.CallbackQuery) -> None:
    try:
        _, deal_id_str, role_type, new_user_id_str = callback.data.split("_")
        deal_id = int(deal_id_str)
        new_user_id = int(new_user_id_str)

        deal = next((d for d in bot_data.current_poll_deals if d["id"] == deal_id), None)
        if not deal:
            await callback.answer("⚠️ Игра не найдена.", show_alert=True)
            return

        # Получаем кандидатов на эту роль
        role_prefix = {
            "main": "lead",
            "assist": "assistant",
            "admin": "admin"
        }[role_type]

        # Ищем текущего участника на этой роли
        dist = bot_data.distribution_cache.get(str(deal_id), {})
        current_key = next((k for k in dist if k.startswith(role_prefix)), None)
        if not current_key:
            await callback.answer("⚠️ Не удалось найти роль.", show_alert=True)
            return

        # Получаем имя нового участника
        user_info = get_user_info(new_user_id)
        if not user_info:
            await callback.answer("⚠️ Пользователь не найден.", show_alert=True)
            return

        name = f"{user_info['first_name']} {user_info['last_name_initial']}"
        suffix = {
            "lead": ".1", "assistant": ".Пом", "admin": ".Ад"
        }.get(role_prefix, "")

        tag = f"{name}{suffix}"

        # Обновляем распределение
        dist[current_key] = tag
        bot_data.distribution_cache[str(deal_id)] = dist

        await callback.answer("✅ Назначение обновлено.")
        # Обновляем интерфейс отчёта одной игры
        await show_deal_callback_handler(callback)

    except Exception as e:
        logger.error("[13.0.1.1] assign_swap_handler: %s", e, exc_info=True)
        await callback.answer("⚠️ Ошибка при замене участника.", show_alert=True)


# ╔═══════════════════════════════════════════════════════════════════════════╗
# ║                   [13.0.2] distribute_leaders_handler                     ║
# ╚═══════════════════════════════════════════════════════════════════════════╝
# Описание: Показывает текущее состояние распределения из кэша
#           (не пересчитывает с нуля, не вызывает create_distribution)
# version: 4.0 (28.05.2025) — читает из distribution_cache

@router.callback_query(lambda c: c.data == "distribute_leaders")
async def distribute_leaders_handler(callback: types.CallbackQuery) -> None:
    user_id = callback.from_user.id
    logger.debug("[13.0.2] distribute_leaders_handler: start for user %d", user_id)

    try:
        if not await has_access(user_id, "poll"):
            await callback.answer("⛔ Нет доступа.", show_alert=True)
            return
        if not bot_data.coordination_cycle_active:
            await callback.answer("⚠️ Нет активного опроса.", show_alert=True)
            return

        if not bot_data.distribution_cache:
            await callback.answer("⚠️ Распределение не выполнено.", show_alert=True)
            return

        report = ["📋 *Предварительное распределение:*"]

        for deal in bot_data.current_poll_deals:
            did = str(deal["id"])
            dist = bot_data.distribution_cache.get(did, {})
            if not dist:
                continue

            report.append(f"\n🎯 *{deal['name']}* — {deal['event_datetime_str']}")

            for role, tag in dist.items():
                emoji = {
                    "lead": "🧭", "assistant": "🛟", "admin": "🛡️", "intern": "👷"
                }.get(role.split("1")[0], "👤")
                txt = tag or "_не назначен_"
                report.append(f"{emoji} {role.capitalize()}: {txt}")

        await callback.message.answer("\n".join(report), parse_mode="Markdown")
        await callback.answer()

        logger.debug("[13.0.2] distribute_leaders_handler: done")

    except Exception as e:
        logger.error("[13.0.2] distribute_leaders_handler: Ошибка: %s", e, exc_info=True)
        await callback.answer("⚠️ Ошибка при показе распределения.", show_alert=True)

# ╔═══════════════════════════════════════════════════════════════════════════╗
# ║            [13.0.3] save_distribution_to_amocrm_handler (fixed)           ║
# ╚═══════════════════════════════════════════════════════════════════════════╝
# Исправлено имя функции update_amocrm_tags + добавлен отчёт об отсутствии данных
# version: 1.1 (30.05.2025)

@router.callback_query(lambda c: c.data == "save_distribution")
async def save_distribution_to_amocrm_handler(callback: types.CallbackQuery) -> None:
    user_id = callback.from_user.id
    logger.debug("[13.0.3] save_distribution_to_amocrm_handler: start for user %d", user_id)

    try:
        # проверка прав
        if not await has_access(user_id, "poll"):
            await callback.answer("⛔ Нет доступа.", show_alert=True)
            return

        # проверка, что распределение уже сформировано
        if not bot_data.distribution_cache:
            await callback.answer("⚠️ Сначала утвердите распределение.", show_alert=True)
            return

        updates: list[str] = []

        for deal in bot_data.current_poll_deals:
            did_str = str(deal["id"])
            dist    = bot_data.distribution_cache.get(did_str, {})
            tags    = [t for t in dist.values() if t]  # только непустые теги

            if not tags:
                updates.append(f"⚠️ {deal['name']} — нет тегов для записи")
                continue

            # сохраняем в AmoCRM
            success = await update_amocrm_tags(deal_id=deal["id"], tags=tags)
            updates.append(f"{'✅' if success else '❌'} {deal['name']}")

        report = "\n".join(updates) if updates else "⚠️ Нет данных для обновления."
        await callback.message.answer(
            f"💾 *Сохранение в AmoCRM:*\n{report}",
            parse_mode="Markdown"
        )
        await callback.answer("Готово.")

        logger.info("[13.0.3] save_distribution_to_amocrm_handler: completed")

    except Exception as e:
        logger.error("[13.0.3] save_distribution_to_amocrm_handler: %s", e, exc_info=True)
        await callback.answer("⚠️ Ошибка при сохранении.", show_alert=True)


# ╔═══════════════════════════════════════════════════════════════════════════╗
# ║                        [13.0.5] report_unknown_names                     ║
# ╚═══════════════════════════════════════════════════════════════════════════╝
# Описание: Сообщает о пользователях, не найденных в базе.
# version: 4.9.0 (MasterBot 12.90)

async def report_unknown_names() -> None:
    logger.debug("[13.0.5] report_unknown_names: start")
    try:
        unknown = []
        for data in bot_data.responses.values():
            for deal_id, users in data["deals"].items():
                for u in users:
                    if not get_user_info(u["user_id"]):
                        unknown.append(u["first_name"])
            for u in data["admin_available"] + data["not_available"]:
                if not get_user_info(u["user_id"]):
                    unknown.append(u["first_name"])
        if unknown:
            text = "⚠️ Неизвестные пользователи: " + ", ".join(sorted(set(unknown)))
            await bot.send_message(bot_data.current_poll_leader, text, parse_mode="Markdown")
        logger.debug("[13.0.5] report_unknown_names: done")
    except Exception as e:
        logger.error("[13.0.5] report_unknown_names: Ошибка при сообщении о неизвестных пользователях: %s", e, exc_info=True)


# ╔═══════════════════════════════════════════════════════════════════════════╗
# ║                         [13.2] clear_poll_data                           ║
# ╚═══════════════════════════════════════════════════════════════════════════╝
# Описание: Очищает данные опроса после завершения или по таймауту.
# version: 12.90

async def clear_poll_data(user_id: int) -> None:
    logger.debug("[13.2] clear_poll_data: start for user %d", user_id)
    try:
        bot_data.responses.clear()
        bot_data.current_poll_deals.clear()
        bot_data.distribution_cache.clear()
        bot_data.personal_report_message_id = None
        bot_data.current_poll_leader = None
        bot_data.coordination_cycle_active = False
        bot_data.distribution_keyboard = None
        bot_data.current_event_period = None
        logger.info("[13.2] clear_poll_data: Данные опроса очищены для пользователя %d", user_id)
    except Exception as e:
        logger.error("[13.2] clear_poll_data: Ошибка при очистке данных опроса для пользователя %d: %s", user_id, e, exc_info=True)


# ╔═══════════════════════════════════════════════════════════════════════════╗
# ║                        [13.3] handle_poll_answer                         ║
# ╚═══════════════════════════════════════════════════════════════════════════╝
# version: 2.0 (26.05.2025) — убрано run_until_complete, отчёт формируется async

@router.poll_answer()
async def handle_poll_answer(event: types.PollAnswer) -> None:
    """Обработка голоса в Telegram-опросе."""
    user_id, poll_id, chosen = event.user.id, event.poll_id, event.option_ids
    logger.debug("[13.3] handle_poll_answer: start poll=%s user=%d choices=%s",
                 poll_id, user_id, chosen)

    if poll_id not in bot_data.responses:      # не наш опрос
        return

    data = bot_data.responses[poll_id]

    # удаляем старые записи пользователя
    for lst in data["deals"].values():
        lst[:] = [u for u in lst if u["user_id"] != user_id]
    data["not_available"][:]   = [u for u in data["not_available"]   if u["user_id"] != user_id]
    data["admin_available"][:] = [u for u in data["admin_available"] if u["user_id"] != user_id]

    ui        = get_user_info(user_id) or {}
    base_user = {
        "user_id": user_id,
        "first_name": ui.get("first_name", ""),
        "last_name_initial": ui.get("last_name_initial", ""),
        "is_admin_eligible": False
    }

    num_games = len(data["deal_indices"])

    for idx in chosen:
        if idx < num_games:                            # игра
            did = data["deal_indices"][idx]
            data["deals"][did].append(base_user.copy())
        elif idx == num_games:                         # 🚫
            data["not_available"].append(base_user.copy())
        elif idx == num_games + 1:                     # 🛡️
            u = base_user.copy(); u["is_admin_eligible"] = True
            data["admin_available"].append(u)

    # обновляем личный отчёт
    try:
        report = await generate_poll_report()
        await bot.edit_message_text(
            report, chat_id=bot_data.current_poll_leader,
            message_id=bot_data.personal_report_message_id,
            parse_mode="Markdown", reply_markup=bot_data.distribution_keyboard
        )
        logger.debug("[13.3] handle_poll_answer: report updated")
    except Exception as e:
        logger.error("[13.3] handle_poll_answer: %s", e, exc_info=True)

# ╔═══════════════════════════════════════════════════════════════════════════╗
# ║                         [13.4] Редактирование состава                     ║
# ╚═══════════════════════════════════════════════════════════════════════════╝
# Описание: Упрощённое редактирование распределения по ролям
# version: 1.0 (27.05.2025) — компактное меню на одну игру

@router.callback_query(lambda c: c.data == "manual_edit")
async def manual_edit_menu(callback: types.CallbackQuery) -> None:
    """Показывает список игр с кнопками редактирования состава."""
    try:
        kb = InlineKeyboardBuilder()
        for deal in bot_data.current_poll_deals:
            name = deal["name"]
            date = deal["event_datetime"].strftime("%d.%m")
            kb.button(text=f"✏️ {name} — {date}", callback_data=f"edit_compact_{deal['id']}")
        kb.adjust(1)

        await callback.message.answer("🛠 Выберите игру для редактирования состава:", reply_markup=kb.as_markup())
        await callback.answer()
    except Exception as e:
        logger.error("[13.4] manual_edit_menu: %s", e, exc_info=True)
        await callback.answer("⚠️ Ошибка отображения игр.", show_alert=True)


@router.callback_query(lambda c: c.data.startswith("edit_compact_"))
async def edit_compact_roles(callback: types.CallbackQuery) -> None:
    """Показывает состав ролей на одну игру, каждая роль — отдельная кнопка."""
    try:
        deal_id = int(callback.data.split("_")[-1])
        deal = next((d for d in bot_data.current_poll_deals if d["id"] == deal_id), None)
        if not deal:
            await callback.answer("⚠️ Игра не найдена.", show_alert=True)
            return

        roles = bot_data.distribution_cache.get(str(deal_id), {})
        kb = InlineKeyboardBuilder()

        for role, name in roles.items():
            btn_text = f"{role.capitalize()}: {name or '—'}"
            kb.button(text=btn_text, callback_data=f"select_user_{deal_id}_{role}")
        kb.adjust(1)

        await callback.message.answer(f"🛠 Состав для *{deal['name']}*:", reply_markup=kb.as_markup(), parse_mode="Markdown")
        await callback.answer()

    except Exception as e:
        logger.error("[13.4] edit_compact_roles: %s", e, exc_info=True)
        await callback.answer("⚠️ Ошибка при отображении ролей.", show_alert=True)


@router.callback_query(lambda c: c.data.startswith("select_user_"))
async def select_user_for_role(callback: types.CallbackQuery) -> None:
    """Показывает кандидатов на конкретную роль в игре."""
    try:
        _, deal_id, role = callback.data.split("_", 2)
        deal_id = int(deal_id)
        deal = next((d for d in bot_data.current_poll_deals if d["id"] == deal_id), None)
        if not deal:
            await callback.answer("⚠️ Игра не найдена.", show_alert=True)
            return

        candidates = []
        for p in bot_data.responses.values():
            candidates += p["deals"].get(deal_id, [])

        # фильтруем по роли
        filtered = []
        for u in candidates:
            status = await get_user_status_from_svetofor(u["user_id"], deal["game_name"])
            if role.startswith("lead") and status == "green":
                filtered.append(u)
            elif role.startswith("assistant") and status in ("green", "yellow"):
                filtered.append(u)
            elif role == "admin" and u.get("is_admin_eligible"):
                filtered.append(u)
            elif role == "intern" and status == "red":
                filtered.append(u)

        kb = InlineKeyboardBuilder()
        for u in filtered:
            name = f"{u['first_name']} {u['last_name_initial']}"
            kb.button(text=name, callback_data=f"assign_{deal_id}_{role}_{u['user_id']}")
        kb.button(text="⛔ Убрать назначение", callback_data=f"assign_{deal_id}_{role}_none")
        kb.adjust(1)

        await callback.message.answer(f"👤 Кандидаты на роль `{role}` в *{deal['name']}*:", reply_markup=kb.as_markup(), parse_mode="Markdown")
        await callback.answer()

    except Exception as e:
        logger.error("[13.4] select_user_for_role: %s", e, exc_info=True)
        await callback.answer("⚠️ Ошибка при выводе кандидатов.", show_alert=True)


@router.callback_query(lambda c: c.data.startswith("assign_"))
async def assign_user_to_role(callback: types.CallbackQuery) -> None:
    """Назначает пользователя на роль или снимает назначение."""
    try:
        _, deal_id, role, user_id = callback.data.split("_", 3)
        deal_id = str(deal_id)
        user_id = None if user_id == "none" else int(user_id)

        if deal_id not in bot_data.distribution_cache:
            bot_data.distribution_cache[deal_id] = {}

        if user_id:
            info = get_user_info(user_id)
            name = f"{info['first_name']} {info['last_name_initial']}" if info else "??"
            suffix = {
                "lead": ".1", "assistant": ".Пом", "admin": ".Ад", "intern": ".Стаж"
            }.get(role.split("1")[0], "")
            tag = f"{name}{suffix}"
        else:
            tag = ""

        bot_data.distribution_cache[deal_id][role] = tag
        await callback.answer("✅ Назначение сохранено.")
        await edit_compact_roles(callback)  # перерисовать меню

    except Exception as e:
        logger.error("[13.4] assign_user_to_role: %s", e, exc_info=True)
        await callback.answer("⚠️ Ошибка при назначении.", show_alert=True)

# ════════════════════════════════════════════════════════════════════════════
# version: 1.0 (27.05.2025)
# История изменений:
# - 1.0: Упрощённый редактор состава по ролям через инлайн-кнопки без вложенных меню


# ╔═══════════════════════════════════════════════════════════════════════════╗
# ║                                                                           ║
# ║                   [15.0] Обновление Google Sheets                         ║
# ║                                                                           ║
# ╚═══════════════════════════════════════════════════════════════════════════╝
# Описание: Функции для записи результатов распределения в Google Sheets.
# version: 1.1

async def create_distribution_table(spreadsheet_id: str, deals: List[Dict], distribution: Dict) -> None:
    """Создаёт таблицу распределения в Google Sheets.

    Args:
        spreadsheet_id: ID таблицы Google Sheets.
        deals: Список сделок.
        distribution: Словарь распределения.
    """
    try:
        creds = Credentials.from_service_account_file(GOOGLE_CREDENTIALS_FILE, scopes=GOOGLE_SHEETS_SCOPES)
        client = gspread.authorize(creds)
        spreadsheet = client.open_by_key(spreadsheet_id)
        sheet = spreadsheet.worksheet(DISTRIBUTION_SPREADSHEET_NAME)

        headers = ["ID сделки", "Название", "Дата и время", "Квест", "Ведущий 1", "Ведущий 2", "Помощник 1", "Помощник 2", "Администратор"]
        data = [headers]

        for deal in deals:
            deal_id = str(deal["id"])
            dist = distribution.get(deal_id, {})
            row = [
                deal["id"],
                deal["name"],
                deal["event_datetime_str"],
                deal["game_name"],
                dist.get("lead1", ""),
                dist.get("lead2", ""),
                dist.get("assistant1", ""),
                dist.get("assistant2", ""),
                dist.get("admin", "")
            ]
            data.append(row)

        sheet.clear()
        sheet.update("A1", data)
        logger.info("[15.0] create_distribution_table: Таблица распределения обновлена, строк: %d", len(data))
    except Exception as e:
        logger.error("[15.0] create_distribution_table: Ошибка обновления таблицы: %s", e, exc_info=True)

# version: 1.1
# История изменений:
# - 1.0: Базовая функция для Google Sheets.
# - 1.1 (11.05.2025): Улучшено логирование, добавлены проверки.

# ╔═══════════════════════════════════════════════════════════════════════════╗
# ║                         [16.0] Отображение игр                            ║
# ╚═══════════════════════════════════════════════════════════════════════════╝
# Кнопка-игра: 🎉 <Название> <HH:MM> <Пакет>  (пакет — только если задан)
# version: 2.3 (обновлено под новые требования)

async def show_games(
    message: types.Message,
    user_id: int,
    status_ids: List[str],
    title: str,
    only_unassigned: bool | None = None
) -> None:
    try:
        spreadsheet_id = bot_data.config.get("svetofor_spread_id")
        if not spreadsheet_id:
            await message.answer("⚠️ Не указан ID таблицы «Светофор».")
            logger.error("[16.0] show_games: svetofor_spread_id отсутствует")
            return

        deals = await get_amocrm_deals(spreadsheet_id)
        if not deals:
            await message.answer(f"{title}\n😔 Игры не найдены.")
            logger.info("[16.0] show_games: нет сделок")
            return

        if only_unassigned is None:
            only_unassigned = (status_ids == NEW_GAMES_STATUS_IDS)

        now = datetime.now(tz=MSK_TZ)
        filtered = [
            d for d in deals
            if d["status_id"] in status_ids
               and d["event_datetime"] >= now
               and (not only_unassigned or not d["team_leads"])
        ]
        if not filtered:
            await message.answer(f"{title}\n😔 Подходящих игр нет.")
            logger.info("[16.0] show_games: фильтры вернули пусто")
            return

        filtered.sort(key=lambda d: d["event_datetime"])
        filtered = filtered[:20]
        bot_data.games_by_user[user_id] = filtered

        kb = InlineKeyboardBuilder()
        for deal in filtered:
            time_part = deal.get("event_time", "")
            # Попытка взять пакет услуг, иначе оставить пустым
            pkg = (deal.get("package") or deal.get("extra_services") or "").strip()
            pkg_part = f" {pkg}" if pkg and pkg != "Не указано" else ""

            btn_text = f"🎉 {deal['name']} {time_part}{pkg_part}"
            kb.button(text=btn_text, callback_data=f"game_details_{deal['id']}")

        kb.adjust(1)
        await message.answer(f"{title}\nВыберите игру:", reply_markup=kb.as_markup())
        logger.info("[16.0] show_games: отправлено %d игр пользователю %d", len(filtered), user_id)

    except Exception as e:
        logger.error("[16.0] show_games: ошибка для %d: %s", user_id, e, exc_info=True)
        await message.answer("⚠️ Ошибка при загрузке списка игр.")





# ╔═══════════════════════════════════════════════════════════════════════════╗
# ║                                                                           ║
# ║                      [17.0] Проверки доступа                              ║
# ║                                                                           ║
# ╚═══════════════════════════════════════════════════════════════════════════╝
# Описание: Функции для проверки прав доступа пользователей.
# version: 1.1

async def has_access(user_id: int, access_type: str) -> bool:
    """Проверяет, имеет ли пользователь доступ к функции.

    Args:
        user_id: ID пользователя.
        access_type: Тип доступа (games, poll, distribution).

    Returns:
        bool: True, если доступ есть.
    """
    try:
        user_info = get_user_info(user_id)
        if not user_info:
            logger.warning("[17.0] has_access: Пользователь %d не найден", user_id)
            return False

        role = user_info.get("role", "")
        has_access = role in ACCESS.get(access_type, [])
        logger.debug("[17.0] has_access: Пользователь %d (%s) запросил %s, доступ: %s", user_id, role, access_type, has_access)
        return has_access
    except Exception as e:
        logger.error("[17.0] has_access: Ошибка для пользователя %d, тип %s: %s", user_id, access_type, e, exc_info=True)
        return False

async def is_bot_admin(chat_id: int) -> bool:
    """Проверяет, является ли бот администратором чата.

    Args:
        chat_id: ID чата.

    Returns:
        bool: True, если бот админ.
    """
    try:
        chat_member = await bot.get_chat_member(chat_id, bot.id)
        is_admin = chat_member.status in ["administrator", "creator"]
        logger.debug("[17.0] is_bot_admin: Бот в чате %d, статус: %s, админ: %s", chat_id, chat_member.status, is_admin)
        return is_admin
    except TelegramAPIError as e:
        logger.error("[17.0] is_bot_admin: Ошибка проверки статуса в чате %d: %s", chat_id, e, exc_info=True)
        return False

# version: 1.1
# История изменений:
# - 1.0: Базовые проверки доступа.
# - 1.1 (11.05.2025): Улучшено логирование, добавлены проверки.
# ╔═══════════════════════════════════════════════════════════════════════════╗
# ║                                                                           ║
# ║                      [18.0] Инициализация бота                            ║
# ║                                                                           ║
# ╚═══════════════════════════════════════════════════════════════════════════╝
# Описание: Загрузка конфигурации и токенов, admin_chat_id, гарантия наличия
#           LEADER_ID в БД, логирование кастом-полей, генерация маппинга и запуск планировщика.
# version: 1.4  (17.05.2025)  ← добавлено логирование AMOCRM_FIELDS

async def on_startup() -> None:
    """Действия при запуске бота."""
    try:
        # загрузка конфигурации
        bot_data.config = await load_json(CONFIG_FILE)
        logger.info("[18.0] on_startup: Конфигурация загружена из %s", CONFIG_FILE)

        # загрузка токенов
        bot_data.tokens = await load_json(TOKENS_FILE)
        logger.info("[18.0] on_startup: Токены загружены из %s", TOKENS_FILE)

        # логирование используемых кастом-полей из AMOCRM_FIELDS
        logger.info("[18.0] Используемые кастом-поля AmoCRM:")
        for name, fid in AMOCRM_FIELDS.items():
            logger.info("    %s → %s", name, fid)

        # получение admin_chat_id
        if os.path.exists(CHAT_ID_FILE):
            with open(CHAT_ID_FILE, "r", encoding="utf-8") as f:
                bot_data.admin_chat_id = json.load(f).get("admin_chat_id")
            logger.info("[18.0] on_startup: admin_chat_id=%s", bot_data.admin_chat_id)
        else:
            logger.warning("[18.0] on_startup: файл %s не найден", CHAT_ID_FILE)

        # ── гарантия LEADER_ID в checklists.db ───────────────────────────────
        import sqlite3
        db_path = os.path.join(BASE_DIR, "checklists.db")
        conn = sqlite3.connect(db_path)
        cur = conn.cursor()
        cur.execute(
            "CREATE TABLE IF NOT EXISTS users ("
            "user_id INTEGER PRIMARY KEY, first_name TEXT, last_name TEXT, role TEXT, scenario_access TEXT)"
        )
        cur.execute(
            "INSERT OR IGNORE INTO users(user_id, first_name, last_name, role) "
            "VALUES (?, '', '', 'руководитель')",
            (LEADER_ID,)
        )
        conn.commit()
        conn.close()
        logger.info("[18.0] on_startup: LEADER_ID %d гарантирован в таблице users", LEADER_ID)
        # ─────────────────────────────────────────────────────────────────────

        # генерация имени-маппинга pipeline и статусов
        await generate_name_mapping()
        logger.info("[18.0] on_startup: Генерация маппинга завершена")

    except Exception as e:
        logger.error("[18.0] on_startup: критическая ошибка: %s", e, exc_info=True)
        raise

async def main() -> None:
    """Точка входа в приложение."""
    try:
        global bot, scheduler
        bot = Bot(token=API_TOKEN, default=DefaultBotProperties(parse_mode="Markdown"))
        dp = Dispatcher()
        scheduler = AsyncIOScheduler(timezone=MSK_TZ)

        dp.include_router(router)
        dp.startup.register(on_startup)
        scheduler.start()

        logger.info("[18.0] main: Бот запущен, версия %s", VERSION)
        await dp.start_polling(bot)
    except Exception as e:
        logger.critical("[18.0] main: Критическая ошибка: %s", e, exc_info=True)
        raise

if __name__ == "__main__":
    asyncio.run(main())

# ────────────────────────────────────────────────────────────────────────────
# История изменений:
# - 1.0 (??.05.2025): базовая инициализация
# - 1.1 (11.05.2025): логи и загрузка chat_id
# - 1.2 (12.05.2025): планировщик с MSK_TZ
# - 1.3 (13.05.2025): вставка LEADER_ID в БД users
# - 1.4 (17.05.2025): логирование AMOCRM_FIELDS перед стартом


# ████████████████████████████████████████████████████████████████████████████
# █                                                                         █
# █                         Конец MasterBot 12.92                            █
# █                                                                         █
# ████████████████████████████████████████████████████████████████████████████
